{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C/C++ Lint Action | clang-format & clang-tidy \u00b6 A Github Action for linting C/C++ code integrating clang-tidy and clang-format to collect feedback provided in the form of thread comments and/or annotations. Usage \u00b6 Create a new GitHub Actions workflow in your project, e.g. at .github/workflows/cpp-linter.yml The content of the file should be in the following format. # Workflow syntax: # https://help.github.com/en/articles/workflow-syntax-for-github-actions name : cpp-linter on : push : paths-ignore : \"docs/**\" pull_request : paths-ignore : \"docs/**\" jobs : cpp-linter : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : shenxianpeng/cpp-linter-action@master id : linter env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : style : file - name : Fail fast?! if : steps.linter.outputs.checks-failed > 0 run : | echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1 Optional Inputs \u00b6 style \u00b6 Description : The style rules to use. Set this to 'file' to have clang-format use the closest relative .clang-format file. Default: 'llvm' extensions \u00b6 Description : The file extensions to run the action against. This is a comma-separated string. Default: 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx' tidy-checks \u00b6 Description : Comma-separated list of globs with optional '-' prefix. Globs are processed in order of appearance in the list. Globs without '-' prefix add checks with matching names to the set, globs with the '-' prefix remove checks with matching names from the set of enabled checks. This option's value is appended to the value of the 'Checks' option in a .clang-tidy file (if any). It is possible to disable clang-tidy entirely by setting this option to '-*'. This allows using only clang-format to lint your source files. Default: 'boost-*,bugprone-*,performance-*,readability-*,portability-*,modernize-*,clang-analyzer-*,cppcoreguidelines-*' repo-root \u00b6 Description : The relative path to the repository root directory. This path is relative to the path designated as the runner's GITHUB_WORKSPACE environment variable. Default: '.' version \u00b6 Description : The desired version of the clang tools to use. Accepted options are strings which can be 6.0, 7, 8, 9, 10, 11, or 12. Default: '10' verbosity \u00b6 Description : This controls the action's verbosity in the workflow's logs. Supported options are defined by the python logging library's log levels. This option does not affect the verbosity of resulting comments or annotations. Default: '10' lines-changed-only \u00b6 Description : Set this option to true to only analyse changes in the event's diff. Default: false files-changed-only \u00b6 Description : Set this option to false to analyse any source files in the repo. Default: true ignore \u00b6 Description : Set this option with string of path(s) to ignore. In the case of multiple paths, you can use a pipe character ('|') to separate the multiple paths. Multiple lines are forbidden as an input to this option; it must be a single string. This can also have files, but the file's relative path has to be specified as well. There is no need to use './' for each entry; a blank string ('') represents the repo-root path (specified by the repo-root input option). Submodules are automatically ignored. Hidden directories (beginning with a '.') are also ignored automatically. Prefix a path with a bang ('!') to make it explicitly not ignored - order of multiple paths does not take precedence. The '!' prefix can be applied to a submodule's path (if desired) but not hidden directories. Glob patterns are not supported here. All asterick characters ('*') are literal. Default: '.github' thread-comments \u00b6 Description : Set this option to false to disable the use of thread comments as feedback. To use thread comments, the GITHUB_TOKEN (provided by Github to each repository) must be declared as an environment variable. See Authenticating with the GITHUB_TOKEN Default: true Outputs \u00b6 This action creates 1 output variable named checks-failed . Even if the linting checks fail for source files this action will still pass, but users' CI workflows can use this action's output to exit the workflow early if that is desired. Example \u00b6 Thread Comment \u00b6 Annotations \u00b6 Add C/C++ Lint Action badge in README \u00b6 You can show C/C++ Lint Action status with a badge in your repository README Example [![cpp-linter](https://github.com/shenxianpeng/cpp-linter-action/actions/workflows/cpp-linter.yml/badge.svg)](https://github.com/shenxianpeng/cpp-linter-action/actions/workflows/cpp-linter.yml) Have question or feedback? \u00b6 To provide feedback (requesting a feature or reporting a bug) please post to issues . License \u00b6 The scripts and documentation in this project are released under the MIT License","title":"Home"},{"location":"#cc-lint-action-clang-format-clang-tidy","text":"A Github Action for linting C/C++ code integrating clang-tidy and clang-format to collect feedback provided in the form of thread comments and/or annotations.","title":"C/C++ Lint Action | clang-format &amp; clang-tidy"},{"location":"#usage","text":"Create a new GitHub Actions workflow in your project, e.g. at .github/workflows/cpp-linter.yml The content of the file should be in the following format. # Workflow syntax: # https://help.github.com/en/articles/workflow-syntax-for-github-actions name : cpp-linter on : push : paths-ignore : \"docs/**\" pull_request : paths-ignore : \"docs/**\" jobs : cpp-linter : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : shenxianpeng/cpp-linter-action@master id : linter env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : style : file - name : Fail fast?! if : steps.linter.outputs.checks-failed > 0 run : | echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1","title":"Usage"},{"location":"#optional-inputs","text":"","title":"Optional Inputs"},{"location":"#style","text":"Description : The style rules to use. Set this to 'file' to have clang-format use the closest relative .clang-format file. Default: 'llvm'","title":"style"},{"location":"#extensions","text":"Description : The file extensions to run the action against. This is a comma-separated string. Default: 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx'","title":"extensions"},{"location":"#tidy-checks","text":"Description : Comma-separated list of globs with optional '-' prefix. Globs are processed in order of appearance in the list. Globs without '-' prefix add checks with matching names to the set, globs with the '-' prefix remove checks with matching names from the set of enabled checks. This option's value is appended to the value of the 'Checks' option in a .clang-tidy file (if any). It is possible to disable clang-tidy entirely by setting this option to '-*'. This allows using only clang-format to lint your source files. Default: 'boost-*,bugprone-*,performance-*,readability-*,portability-*,modernize-*,clang-analyzer-*,cppcoreguidelines-*'","title":"tidy-checks"},{"location":"#repo-root","text":"Description : The relative path to the repository root directory. This path is relative to the path designated as the runner's GITHUB_WORKSPACE environment variable. Default: '.'","title":"repo-root"},{"location":"#version","text":"Description : The desired version of the clang tools to use. Accepted options are strings which can be 6.0, 7, 8, 9, 10, 11, or 12. Default: '10'","title":"version"},{"location":"#verbosity","text":"Description : This controls the action's verbosity in the workflow's logs. Supported options are defined by the python logging library's log levels. This option does not affect the verbosity of resulting comments or annotations. Default: '10'","title":"verbosity"},{"location":"#lines-changed-only","text":"Description : Set this option to true to only analyse changes in the event's diff. Default: false","title":"lines-changed-only"},{"location":"#files-changed-only","text":"Description : Set this option to false to analyse any source files in the repo. Default: true","title":"files-changed-only"},{"location":"#ignore","text":"Description : Set this option with string of path(s) to ignore. In the case of multiple paths, you can use a pipe character ('|') to separate the multiple paths. Multiple lines are forbidden as an input to this option; it must be a single string. This can also have files, but the file's relative path has to be specified as well. There is no need to use './' for each entry; a blank string ('') represents the repo-root path (specified by the repo-root input option). Submodules are automatically ignored. Hidden directories (beginning with a '.') are also ignored automatically. Prefix a path with a bang ('!') to make it explicitly not ignored - order of multiple paths does not take precedence. The '!' prefix can be applied to a submodule's path (if desired) but not hidden directories. Glob patterns are not supported here. All asterick characters ('*') are literal. Default: '.github'","title":"ignore"},{"location":"#thread-comments","text":"Description : Set this option to false to disable the use of thread comments as feedback. To use thread comments, the GITHUB_TOKEN (provided by Github to each repository) must be declared as an environment variable. See Authenticating with the GITHUB_TOKEN Default: true","title":"thread-comments"},{"location":"#outputs","text":"This action creates 1 output variable named checks-failed . Even if the linting checks fail for source files this action will still pass, but users' CI workflows can use this action's output to exit the workflow early if that is desired.","title":"Outputs"},{"location":"#example","text":"","title":"Example"},{"location":"#thread-comment","text":"","title":"Thread Comment"},{"location":"#annotations","text":"","title":"Annotations"},{"location":"#add-cc-lint-action-badge-in-readme","text":"You can show C/C++ Lint Action status with a badge in your repository README Example [![cpp-linter](https://github.com/shenxianpeng/cpp-linter-action/actions/workflows/cpp-linter.yml/badge.svg)](https://github.com/shenxianpeng/cpp-linter-action/actions/workflows/cpp-linter.yml)","title":"Add C/C++ Lint Action badge in README"},{"location":"#have-question-or-feedback","text":"To provide feedback (requesting a feature or reporting a bug) please post to issues .","title":"Have question or feedback?"},{"location":"#license","text":"The scripts and documentation in this project are released under the MIT License","title":"License"},{"location":"API%20Reference/cpp_linter.clang_format_xml/","text":"clang_format_xml module \u00b6 Info This API is experimental and not actually used in production. Parse output from clang-format's XML suggestions. FormatReplacement \u00b6 An object representing a single replacement. Attributes: Name Type Description cols int The columns number of where the suggestion starts on the line null_len int The number of bytes removed by suggestion text str The bytearray of the suggestion Source code in cpp_linter/clang_format_xml.py class FormatReplacement : \"\"\"An object representing a single replacement. Attributes: cols (int): The columns number of where the suggestion starts on the line null_len (int): The number of bytes removed by suggestion text (str): The `bytearray` of the suggestion \"\"\" def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text def __repr__ ( self ) -> str : return ( f \"<FormatReplacement at cols { self . cols } removes { self . null_len } bytes\" f \" adds { len ( self . text ) } bytes>\" ) __init__ ( self , cols , null_len , text ) special \u00b6 Parameters: Name Type Description Default cols int The columns number of where the suggestion starts on the line required null_len int The number of bytes removed by suggestion required text str The bytearray of the suggestion required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text FormatReplacementLine \u00b6 An object that represents a replacement(s) for a single line. Attributes: Name Type Description line int The line number of where the suggestion starts replacements list A list of FormatReplacement object(s) representing suggestions. Source code in cpp_linter/clang_format_xml.py class FormatReplacementLine : \"\"\"An object that represents a replacement(s) for a single line. Attributes: line (int): The line number of where the suggestion starts replacements (list): A list of [`FormatReplacement`][cpp_linter.clang_format_xml.FormatReplacement] object(s) representing suggestions. \"\"\" def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements = [] def __repr__ ( self ): return ( f \"<FormatReplacementLine @ line { self . line } \" f \"with { len ( self . replacements ) } replacements>\" ) __init__ ( self , line_numb ) special \u00b6 Parameters: Name Type Description Default line_numb int The line number of about the replacements required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements = [] XMLFixit \u00b6 A single object to represent each suggestion. Attributes: Name Type Description filename str The source file that the suggestion concerns. replaced_lines list A list of [ FormatReplacementLine ][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. Source code in cpp_linter/clang_format_xml.py class XMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file that the suggestion concerns. replaced_lines (list): A list of [`FormatReplacementLine`][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. \"\"\" def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = filename . replace ( os . sep , \"/\" ) self . replaced_lines = [] def __repr__ ( self ) -> str : return ( f \"<XMLFixit with { len ( self . replaced_lines ) } lines of \" f \"replacements for { self . filename } >\" ) def log_command ( self , style : str ) -> str : \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( str ( f . line ) for f in self . replaced_lines ), style_guide = style , ) ) __init__ ( self , filename ) special \u00b6 Parameters: Name Type Description Default filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = filename . replace ( os . sep , \"/\" ) self . replaced_lines = [] log_command ( self , style ) \u00b6 Output a notification as a github log command. Info An error message A warning message A notice message Parameters: Name Type Description Default style str The chosen code style guidelines. required Source code in cpp_linter/clang_format_xml.py def log_command ( self , style : str ) -> str : \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( str ( f . line ) for f in self . replaced_lines ), style_guide = style , ) ) parse_format_replacements_xml ( src_filename ) \u00b6 Parse XML output of replacements from clang-format. Output is saved to format_advice . Parameters: Name Type Description Default src_filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def parse_format_replacements_xml ( src_filename : str ): \"\"\"Parse XML output of replacements from clang-format. Output is saved to [`format_advice`][cpp_linter.__init__.GlobalParser.format_advice]. Args: src_filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" tree = ET . parse ( \"clang_format_output.xml\" ) fixit = XMLFixit ( src_filename ) for child in tree . getroot (): if child . tag == \"replacement\" : offset = int ( child . attrib [ \"offset\" ]) line , cols = get_line_cnt_from_cols ( src_filename , offset ) null_len = int ( child . attrib [ \"length\" ]) text = \"\" if child . text is None else child . text fix = FormatReplacement ( cols , null_len , text ) if not fixit . replaced_lines or ( fixit . replaced_lines and line != fixit . replaced_lines [ - 1 ] . line ): line_fix = FormatReplacementLine ( line ) line_fix . replacements . append ( fix ) fixit . replaced_lines . append ( line_fix ) elif fixit . replaced_lines and line == fixit . replaced_lines [ - 1 ] . line : fixit . replaced_lines [ - 1 ] . replacements . append ( fix ) GlobalParser . format_advice . append ( fixit ) print_fixits () \u00b6 Print all XMLFixit objects in format_advice . Source code in cpp_linter/clang_format_xml.py def print_fixits (): \"\"\"Print all [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit] objects in [`format_advice`][cpp_linter.__init__.GlobalParser.format_advice].\"\"\" for fixit in GlobalParser . format_advice : print ( repr ( fixit )) for line_fix in fixit . replaced_lines : print ( \" \" + repr ( line_fix )) for fix in line_fix . replacements : print ( \" \\t \" + repr ( fix ))","title":"clang_format_xml module"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#clang_format_xml-module","text":"Info This API is experimental and not actually used in production. Parse output from clang-format's XML suggestions.","title":"clang_format_xml module"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacement","text":"An object representing a single replacement. Attributes: Name Type Description cols int The columns number of where the suggestion starts on the line null_len int The number of bytes removed by suggestion text str The bytearray of the suggestion Source code in cpp_linter/clang_format_xml.py class FormatReplacement : \"\"\"An object representing a single replacement. Attributes: cols (int): The columns number of where the suggestion starts on the line null_len (int): The number of bytes removed by suggestion text (str): The `bytearray` of the suggestion \"\"\" def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text def __repr__ ( self ) -> str : return ( f \"<FormatReplacement at cols { self . cols } removes { self . null_len } bytes\" f \" adds { len ( self . text ) } bytes>\" )","title":"FormatReplacement"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacement.__init__","text":"Parameters: Name Type Description Default cols int The columns number of where the suggestion starts on the line required null_len int The number of bytes removed by suggestion required text str The bytearray of the suggestion required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacementLine","text":"An object that represents a replacement(s) for a single line. Attributes: Name Type Description line int The line number of where the suggestion starts replacements list A list of FormatReplacement object(s) representing suggestions. Source code in cpp_linter/clang_format_xml.py class FormatReplacementLine : \"\"\"An object that represents a replacement(s) for a single line. Attributes: line (int): The line number of where the suggestion starts replacements (list): A list of [`FormatReplacement`][cpp_linter.clang_format_xml.FormatReplacement] object(s) representing suggestions. \"\"\" def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements = [] def __repr__ ( self ): return ( f \"<FormatReplacementLine @ line { self . line } \" f \"with { len ( self . replacements ) } replacements>\" )","title":"FormatReplacementLine"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacementLine.__init__","text":"Parameters: Name Type Description Default line_numb int The line number of about the replacements required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit","text":"A single object to represent each suggestion. Attributes: Name Type Description filename str The source file that the suggestion concerns. replaced_lines list A list of [ FormatReplacementLine ][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. Source code in cpp_linter/clang_format_xml.py class XMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file that the suggestion concerns. replaced_lines (list): A list of [`FormatReplacementLine`][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. \"\"\" def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = filename . replace ( os . sep , \"/\" ) self . replaced_lines = [] def __repr__ ( self ) -> str : return ( f \"<XMLFixit with { len ( self . replaced_lines ) } lines of \" f \"replacements for { self . filename } >\" ) def log_command ( self , style : str ) -> str : \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( str ( f . line ) for f in self . replaced_lines ), style_guide = style , ) )","title":"XMLFixit"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit.__init__","text":"Parameters: Name Type Description Default filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = filename . replace ( os . sep , \"/\" ) self . replaced_lines = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit.log_command","text":"Output a notification as a github log command. Info An error message A warning message A notice message Parameters: Name Type Description Default style str The chosen code style guidelines. required Source code in cpp_linter/clang_format_xml.py def log_command ( self , style : str ) -> str : \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( str ( f . line ) for f in self . replaced_lines ), style_guide = style , ) )","title":"log_command()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.parse_format_replacements_xml","text":"Parse XML output of replacements from clang-format. Output is saved to format_advice . Parameters: Name Type Description Default src_filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def parse_format_replacements_xml ( src_filename : str ): \"\"\"Parse XML output of replacements from clang-format. Output is saved to [`format_advice`][cpp_linter.__init__.GlobalParser.format_advice]. Args: src_filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" tree = ET . parse ( \"clang_format_output.xml\" ) fixit = XMLFixit ( src_filename ) for child in tree . getroot (): if child . tag == \"replacement\" : offset = int ( child . attrib [ \"offset\" ]) line , cols = get_line_cnt_from_cols ( src_filename , offset ) null_len = int ( child . attrib [ \"length\" ]) text = \"\" if child . text is None else child . text fix = FormatReplacement ( cols , null_len , text ) if not fixit . replaced_lines or ( fixit . replaced_lines and line != fixit . replaced_lines [ - 1 ] . line ): line_fix = FormatReplacementLine ( line ) line_fix . replacements . append ( fix ) fixit . replaced_lines . append ( line_fix ) elif fixit . replaced_lines and line == fixit . replaced_lines [ - 1 ] . line : fixit . replaced_lines [ - 1 ] . replacements . append ( fix ) GlobalParser . format_advice . append ( fixit )","title":"parse_format_replacements_xml()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.print_fixits","text":"Print all XMLFixit objects in format_advice . Source code in cpp_linter/clang_format_xml.py def print_fixits (): \"\"\"Print all [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit] objects in [`format_advice`][cpp_linter.__init__.GlobalParser.format_advice].\"\"\" for fixit in GlobalParser . format_advice : print ( repr ( fixit )) for line_fix in fixit . replaced_lines : print ( \" \" + repr ( line_fix )) for fix in line_fix . replacements : print ( \" \\t \" + repr ( fix ))","title":"print_fixits()"},{"location":"API%20Reference/cpp_linter.clang_tidy/","text":"clang_tidy module \u00b6 Parse output from clang-tidy's stdout TidyNotification \u00b6 Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: Name Type Description diagnostic str The clang-tidy check that enabled the notification. filename str The source filename concerning the notification. line int The line number of the source file. cols int The columns of the line that triggered the notification. note_type str The priority level of notification (warning/error). note_info str The rationale of the notification. fixit_lines list A list of lines ( str ) for the code-block in the notification. Source code in cpp_linter/clang_tidy.py class TidyNotification : \"\"\"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: diagnostic (str): The clang-tidy check that enabled the notification. filename (str): The source filename concerning the notification. line (int): The line number of the source file. cols (int): The columns of the line that triggered the notification. note_type (str): The priority level of notification (warning/error). note_info (str): The rationale of the notification. fixit_lines (list): A `list` of lines (`str`) for the code-block in the notification. \"\"\" def __init__ ( self , notification_line : tuple ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = self . filename . replace ( os . getcwd () + os . sep , \"\" ) self . fixit_lines = [] def __repr__ ( self ) -> str : return ( \"<details open> \\n <summary><strong> {} : {} : {} :</strong> {} : [ {} ]\" \" \\n\\n > {} \\n </summary><p> \\n\\n ``` {} \\n {} ``` \\n </p> \\n </details> \\n\\n \" . format ( self . filename , self . line , self . cols , self . note_type , self . diagnostic , self . note_info , os . path . splitext ( self . filename )[ 1 ], \"\" . join ( self . fixit_lines ), ) ) def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" return \":: {} file= {} ,line= {} ,title= {} : {} : {} [ {} ]:: {} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , self . filename , self . line , self . filename , self . line , self . cols , self . diagnostic , self . note_info , ) __init__ ( self , notification_line ) special \u00b6 Parameters: Name Type Description Default notification_line tuple The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. required Source code in cpp_linter/clang_tidy.py def __init__ ( self , notification_line : tuple ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = self . filename . replace ( os . getcwd () + os . sep , \"\" ) self . fixit_lines = [] log_command ( self ) \u00b6 Output the notification as a github log command. Info An error message A warning message A notice message Source code in cpp_linter/clang_tidy.py def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" return \":: {} file= {} ,line= {} ,title= {} : {} : {} [ {} ]:: {} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , self . filename , self . line , self . filename , self . line , self . cols , self . diagnostic , self . note_info , ) parse_tidy_output () \u00b6 Parse clang-tidy output in a file created from stdout. Source code in cpp_linter/clang_tidy.py def parse_tidy_output () -> None : \"\"\"Parse clang-tidy output in a file created from stdout.\"\"\" notification = None with open ( \"clang_tidy_report.txt\" , \"r\" , encoding = \"utf-8\" ) as tidy_out : for line in tidy_out . readlines (): match = re . match ( NOTE_HEADER , line ) if match is not None : notification = TidyNotification ( match . groups ()) GlobalParser . tidy_notes . append ( notification ) elif notification is not None : notification . fixit_lines . append ( line ) print_fixits () \u00b6 Print out all clang-tidy notifications from stdout (which are saved to clang_tidy_report.txt and allocated to tidy_notes . Source code in cpp_linter/clang_tidy.py def print_fixits (): \"\"\"Print out all clang-tidy notifications from stdout (which are saved to clang_tidy_report.txt and allocated to [`tidy_notes`][cpp_linter.__init__.GlobalParser.tidy_notes].\"\"\" for notification in GlobalParser . tidy_notes : print ( \"found\" , len ( GlobalParser . tidy_notes ), \"tidy_notes\" ) print ( repr ( notification ))","title":"clang_tidy module"},{"location":"API%20Reference/cpp_linter.clang_tidy/#clang_tidy-module","text":"Parse output from clang-tidy's stdout","title":"clang_tidy module"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification","text":"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: Name Type Description diagnostic str The clang-tidy check that enabled the notification. filename str The source filename concerning the notification. line int The line number of the source file. cols int The columns of the line that triggered the notification. note_type str The priority level of notification (warning/error). note_info str The rationale of the notification. fixit_lines list A list of lines ( str ) for the code-block in the notification. Source code in cpp_linter/clang_tidy.py class TidyNotification : \"\"\"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: diagnostic (str): The clang-tidy check that enabled the notification. filename (str): The source filename concerning the notification. line (int): The line number of the source file. cols (int): The columns of the line that triggered the notification. note_type (str): The priority level of notification (warning/error). note_info (str): The rationale of the notification. fixit_lines (list): A `list` of lines (`str`) for the code-block in the notification. \"\"\" def __init__ ( self , notification_line : tuple ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = self . filename . replace ( os . getcwd () + os . sep , \"\" ) self . fixit_lines = [] def __repr__ ( self ) -> str : return ( \"<details open> \\n <summary><strong> {} : {} : {} :</strong> {} : [ {} ]\" \" \\n\\n > {} \\n </summary><p> \\n\\n ``` {} \\n {} ``` \\n </p> \\n </details> \\n\\n \" . format ( self . filename , self . line , self . cols , self . note_type , self . diagnostic , self . note_info , os . path . splitext ( self . filename )[ 1 ], \"\" . join ( self . fixit_lines ), ) ) def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" return \":: {} file= {} ,line= {} ,title= {} : {} : {} [ {} ]:: {} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , self . filename , self . line , self . filename , self . line , self . cols , self . diagnostic , self . note_info , )","title":"TidyNotification"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification.__init__","text":"Parameters: Name Type Description Default notification_line tuple The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. required Source code in cpp_linter/clang_tidy.py def __init__ ( self , notification_line : tuple ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = self . filename . replace ( os . getcwd () + os . sep , \"\" ) self . fixit_lines = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification.log_command","text":"Output the notification as a github log command. Info An error message A warning message A notice message Source code in cpp_linter/clang_tidy.py def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" return \":: {} file= {} ,line= {} ,title= {} : {} : {} [ {} ]:: {} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , self . filename , self . line , self . filename , self . line , self . cols , self . diagnostic , self . note_info , )","title":"log_command()"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.parse_tidy_output","text":"Parse clang-tidy output in a file created from stdout. Source code in cpp_linter/clang_tidy.py def parse_tidy_output () -> None : \"\"\"Parse clang-tidy output in a file created from stdout.\"\"\" notification = None with open ( \"clang_tidy_report.txt\" , \"r\" , encoding = \"utf-8\" ) as tidy_out : for line in tidy_out . readlines (): match = re . match ( NOTE_HEADER , line ) if match is not None : notification = TidyNotification ( match . groups ()) GlobalParser . tidy_notes . append ( notification ) elif notification is not None : notification . fixit_lines . append ( line )","title":"parse_tidy_output()"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.print_fixits","text":"Print out all clang-tidy notifications from stdout (which are saved to clang_tidy_report.txt and allocated to tidy_notes . Source code in cpp_linter/clang_tidy.py def print_fixits (): \"\"\"Print out all clang-tidy notifications from stdout (which are saved to clang_tidy_report.txt and allocated to [`tidy_notes`][cpp_linter.__init__.GlobalParser.tidy_notes].\"\"\" for notification in GlobalParser . tidy_notes : print ( \"found\" , len ( GlobalParser . tidy_notes ), \"tidy_notes\" ) print ( repr ( notification ))","title":"print_fixits()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/","text":"clang_tidy_yml module \u00b6 Info This API is experimental and not actually used in production. Parse output from clang-tidy's YML format TidyDiagnostic \u00b6 Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: Name Type Description name str The diagnostic name message str The diagnostic message line int The line number that triggered the diagnostic cols int The columns of the line that triggered the diagnostic null_len int The number of bytes replaced by suggestions replacements list The list of TidyReplacement objects. Source code in cpp_linter/clang_tidy_yml.py class TidyDiagnostic : \"\"\"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: name (str): The diagnostic name message (str): The diagnostic message line (int): The line number that triggered the diagnostic cols (int): The columns of the `line` that triggered the diagnostic null_len (int): The number of bytes replaced by suggestions replacements (list): The `list` of [`TidyReplacement`][cpp_linter.clang_tidy_yml.TidyReplacement] objects. \"\"\" def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements = [] def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" ) __init__ ( self , diagnostic_name ) special \u00b6 Parameters: Name Type Description Default diagnostic_name str The name of the check that got triggered. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements = [] __repr__ ( self ) special \u00b6 a str representation of all attributes. Source code in cpp_linter/clang_tidy_yml.py def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" ) TidyReplacement \u00b6 Create an object representing a clang-tidy suggested replacement. Attributes: Name Type Description line int The replacement content's starting line cols int The replacement content's starting columns null_len int The number of bytes discarded from cols text list The replacement content's text (each str item is a line) Source code in cpp_linter/clang_tidy_yml.py class TidyReplacement : \"\"\"Create an object representing a clang-tidy suggested replacement. Attributes: line (int): The replacement content's starting line cols (int): The replacement content's starting columns null_len (int): The number of bytes discarded from `cols` text (list): The replacement content's text (each `str` item is a line) \"\"\" def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text = [] def __repr__ ( self ) -> str : return ( f \"<TidyReplacement @ line { self . line } cols { self . cols } : \" f \"added lines { len ( self . text ) } discarded bytes { self . null_len } >\" ) __init__ ( self , line_cnt , cols , length ) special \u00b6 Parameters: Name Type Description Default line_cnt int The replacement content's starting line required cols int The replacement content's starting columns required length int The number of bytes discarded from cols required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text = [] YMLFixit \u00b6 A single object to represent each suggestion. Attributes: Name Type Description filename str The source file's name concerning the suggestion. diagnostics list The list of TidyDiagnostic objects. Source code in cpp_linter/clang_tidy_yml.py class YMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file's name concerning the suggestion. diagnostics (list): The `list` of [`TidyDiagnostic`][cpp_linter.clang_tidy_yml.TidyDiagnostic] objects. \"\"\" def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = filename . replace ( os . getcwd () + os . sep , \"\" ) . replace ( os . sep , \"/\" ) self . diagnostics = [] def __repr__ ( self ) -> str : return ( f \"<YMLFixit ( { len ( self . diagnostics ) } diagnostics) for file \" f \" { self . filename } >\" ) __init__ ( self , filename ) special \u00b6 Parameters: Name Type Description Default filename str The source file's name (with path) concerning the suggestion. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = filename . replace ( os . getcwd () + os . sep , \"\" ) . replace ( os . sep , \"/\" ) self . diagnostics = [] parse_tidy_suggestions_yml () \u00b6 Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def parse_tidy_suggestions_yml (): \"\"\"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to [`tidy_advice`][cpp_linter.__init__.GlobalParser.tidy_advice]. \"\"\" yml = {} with open ( \"clang_tidy_output.yml\" , \"r\" , encoding = \"utf-8\" ) as yml_file : yml = yaml . safe_load ( yml_file ) fixit = YMLFixit ( yml [ \"MainSourceFile\" ]) for diag_results in yml [ \"Diagnostics\" ]: diag = TidyDiagnostic ( diag_results [ \"DiagnosticName\" ]) diag . message = diag_results [ \"DiagnosticMessage\" ][ \"Message\" ] diag . line , diag . cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], diag_results [ \"DiagnosticMessage\" ][ \"FileOffset\" ] ) for replacement in diag_results [ \"DiagnosticMessage\" ][ \"Replacements\" ]: line_cnt , cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], replacement [ \"Offset\" ] ) fix = TidyReplacement ( line_cnt , cols , replacement [ \"Length\" ]) fix . text = bytes ( replacement [ \"ReplacementText\" ], encoding = \"utf-8\" ) if fix . text . startswith ( b \"header is missing header guard\" ): print ( \"filtering header guard suggestion (making relative to repo root)\" ) fix . text = fix . text . replace ( CWD_HEADER_GAURD , b \"\" ) diag . replacements . append ( fix ) fixit . diagnostics . append ( diag ) # filter out absolute header gaurds GlobalParser . tidy_advice . append ( fixit ) print_fixits () \u00b6 Print all YMLFixit objects in tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def print_fixits (): \"\"\"Print all [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit] objects in [`tidy_advice`][cpp_linter.__init__.GlobalParser.tidy_advice].\"\"\" for fix in GlobalParser . tidy_advice : for diag in fix . diagnostics : print ( repr ( diag )) for replac in diag . replacements : print ( \" \" + repr ( replac ), f \" \\n\\t replace text: \\n { replac . text } \" )","title":"clang_tidy_yml module"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#clang_tidy_yml-module","text":"Info This API is experimental and not actually used in production. Parse output from clang-tidy's YML format","title":"clang_tidy_yml module"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic","text":"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: Name Type Description name str The diagnostic name message str The diagnostic message line int The line number that triggered the diagnostic cols int The columns of the line that triggered the diagnostic null_len int The number of bytes replaced by suggestions replacements list The list of TidyReplacement objects. Source code in cpp_linter/clang_tidy_yml.py class TidyDiagnostic : \"\"\"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: name (str): The diagnostic name message (str): The diagnostic message line (int): The line number that triggered the diagnostic cols (int): The columns of the `line` that triggered the diagnostic null_len (int): The number of bytes replaced by suggestions replacements (list): The `list` of [`TidyReplacement`][cpp_linter.clang_tidy_yml.TidyReplacement] objects. \"\"\" def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements = [] def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" )","title":"TidyDiagnostic"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic.__init__","text":"Parameters: Name Type Description Default diagnostic_name str The name of the check that got triggered. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic.__repr__","text":"a str representation of all attributes. Source code in cpp_linter/clang_tidy_yml.py def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" )","title":"__repr__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyReplacement","text":"Create an object representing a clang-tidy suggested replacement. Attributes: Name Type Description line int The replacement content's starting line cols int The replacement content's starting columns null_len int The number of bytes discarded from cols text list The replacement content's text (each str item is a line) Source code in cpp_linter/clang_tidy_yml.py class TidyReplacement : \"\"\"Create an object representing a clang-tidy suggested replacement. Attributes: line (int): The replacement content's starting line cols (int): The replacement content's starting columns null_len (int): The number of bytes discarded from `cols` text (list): The replacement content's text (each `str` item is a line) \"\"\" def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text = [] def __repr__ ( self ) -> str : return ( f \"<TidyReplacement @ line { self . line } cols { self . cols } : \" f \"added lines { len ( self . text ) } discarded bytes { self . null_len } >\" )","title":"TidyReplacement"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyReplacement.__init__","text":"Parameters: Name Type Description Default line_cnt int The replacement content's starting line required cols int The replacement content's starting columns required length int The number of bytes discarded from cols required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.YMLFixit","text":"A single object to represent each suggestion. Attributes: Name Type Description filename str The source file's name concerning the suggestion. diagnostics list The list of TidyDiagnostic objects. Source code in cpp_linter/clang_tidy_yml.py class YMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file's name concerning the suggestion. diagnostics (list): The `list` of [`TidyDiagnostic`][cpp_linter.clang_tidy_yml.TidyDiagnostic] objects. \"\"\" def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = filename . replace ( os . getcwd () + os . sep , \"\" ) . replace ( os . sep , \"/\" ) self . diagnostics = [] def __repr__ ( self ) -> str : return ( f \"<YMLFixit ( { len ( self . diagnostics ) } diagnostics) for file \" f \" { self . filename } >\" )","title":"YMLFixit"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.YMLFixit.__init__","text":"Parameters: Name Type Description Default filename str The source file's name (with path) concerning the suggestion. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = filename . replace ( os . getcwd () + os . sep , \"\" ) . replace ( os . sep , \"/\" ) self . diagnostics = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.parse_tidy_suggestions_yml","text":"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def parse_tidy_suggestions_yml (): \"\"\"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to [`tidy_advice`][cpp_linter.__init__.GlobalParser.tidy_advice]. \"\"\" yml = {} with open ( \"clang_tidy_output.yml\" , \"r\" , encoding = \"utf-8\" ) as yml_file : yml = yaml . safe_load ( yml_file ) fixit = YMLFixit ( yml [ \"MainSourceFile\" ]) for diag_results in yml [ \"Diagnostics\" ]: diag = TidyDiagnostic ( diag_results [ \"DiagnosticName\" ]) diag . message = diag_results [ \"DiagnosticMessage\" ][ \"Message\" ] diag . line , diag . cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], diag_results [ \"DiagnosticMessage\" ][ \"FileOffset\" ] ) for replacement in diag_results [ \"DiagnosticMessage\" ][ \"Replacements\" ]: line_cnt , cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], replacement [ \"Offset\" ] ) fix = TidyReplacement ( line_cnt , cols , replacement [ \"Length\" ]) fix . text = bytes ( replacement [ \"ReplacementText\" ], encoding = \"utf-8\" ) if fix . text . startswith ( b \"header is missing header guard\" ): print ( \"filtering header guard suggestion (making relative to repo root)\" ) fix . text = fix . text . replace ( CWD_HEADER_GAURD , b \"\" ) diag . replacements . append ( fix ) fixit . diagnostics . append ( diag ) # filter out absolute header gaurds GlobalParser . tidy_advice . append ( fixit )","title":"parse_tidy_suggestions_yml()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.print_fixits","text":"Print all YMLFixit objects in tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def print_fixits (): \"\"\"Print all [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit] objects in [`tidy_advice`][cpp_linter.__init__.GlobalParser.tidy_advice].\"\"\" for fix in GlobalParser . tidy_advice : for diag in fix . diagnostics : print ( repr ( diag )) for replac in diag . replacements : print ( \" \" + repr ( replac ), f \" \\n\\t replace text: \\n { replac . text } \" )","title":"print_fixits()"},{"location":"API%20Reference/cpp_linter/","text":"Base module \u00b6 The Base module of the cpp_linter package. This holds the objects shared by multiple modules. GlobalParser \u00b6 Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. Source code in cpp_linter/__init__.py class GlobalParser : \"\"\"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. \"\"\" tidy_notes = [] \"\"\"This can only be a `list` of type [`TidyNotification`][cpp_linter.clang_tidy.TidyNotification]\"\"\" tidy_advice = [] \"\"\"This can only be a `list` of type [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit]\"\"\" format_advice = [] \"\"\"This can only be a `list` of type [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit]\"\"\" format_advice \u00b6 This can only be a list of type XMLFixit tidy_advice \u00b6 This can only be a list of type YMLFixit tidy_notes \u00b6 This can only be a list of type TidyNotification Globals \u00b6 Global variables for re-use (non-constant). Source code in cpp_linter/__init__.py class Globals : \"\"\"Global variables for re-use (non-constant).\"\"\" PAYLOAD_TIDY = \"\" \"\"\"The accumulated output of clang-tidy (gets appended to OUTPUT)\"\"\" OUTPUT = \"\" \"\"\"The accumulated body of the resulting comment that gets posted.\"\"\" FILES = [] \"\"\"The reponding payload containing info about changed files.\"\"\" EVENT_PAYLOAD = {} \"\"\"The parsed JSON of the event payload.\"\"\" response_buffer = None \"\"\"A shared response object for `requests` module.\"\"\" EVENT_PAYLOAD \u00b6 The parsed JSON of the event payload. FILES \u00b6 The reponding payload containing info about changed files. OUTPUT \u00b6 The accumulated body of the resulting comment that gets posted. PAYLOAD_TIDY \u00b6 The accumulated output of clang-tidy (gets appended to OUTPUT) response_buffer \u00b6 A shared response object for requests module. get_line_cnt_from_cols ( file_path , offset ) \u00b6 Gets a line count and columns offset from a file's absolute offset. Parameters: Name Type Description Default file_path str Path to file. required offset int The byte offset to translate required Returns: Type Description A `tuple` of 2 `int` numbers Index 0 is the line number for the given offset. Index 1 is the column number for the given offset on the line. Source code in cpp_linter/__init__.py def get_line_cnt_from_cols ( file_path : str , offset : int ) -> tuple : \"\"\"Gets a line count and columns offset from a file's absolute offset. Args: file_path: Path to file. offset: The byte offset to translate Returns: A `tuple` of 2 `int` numbers: - Index 0 is the line number for the given offset. - Index 1 is the column number for the given offset on the line. \"\"\" line_cnt = 1 last_lf_pos = 0 cols = 1 file_path = file_path . replace ( \"/\" , os . sep ) # logger.debug(\"Getting line count from %s at offset %d\", file_path, offset) with io . open ( file_path , \"rb\" ) as src_file : max_len = src_file . seek ( 0 , io . SEEK_END ) src_file . seek ( 0 , io . SEEK_SET ) while src_file . tell () != offset and src_file . tell () < max_len : char = src_file . read ( 1 ) if char == b \" \\n \" : line_cnt += 1 last_lf_pos = src_file . tell () - 1 # -1 because LF is part of offset cols = src_file . tell () - last_lf_pos return ( line_cnt , cols ) log_response_msg () \u00b6 Output the response buffer's message on a failed request. Source code in cpp_linter/__init__.py def log_response_msg (): \"\"\"Output the response buffer's message on a failed request.\"\"\" if Globals . response_buffer . status_code >= 400 : logger . error ( \"response returned message: %s \" , Globals . response_buffer . text )","title":"Base module"},{"location":"API%20Reference/cpp_linter/#base-module","text":"The Base module of the cpp_linter package. This holds the objects shared by multiple modules.","title":"Base module"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.GlobalParser","text":"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. Source code in cpp_linter/__init__.py class GlobalParser : \"\"\"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. \"\"\" tidy_notes = [] \"\"\"This can only be a `list` of type [`TidyNotification`][cpp_linter.clang_tidy.TidyNotification]\"\"\" tidy_advice = [] \"\"\"This can only be a `list` of type [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit]\"\"\" format_advice = [] \"\"\"This can only be a `list` of type [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit]\"\"\"","title":"GlobalParser"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.GlobalParser.format_advice","text":"This can only be a list of type XMLFixit","title":"format_advice"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.GlobalParser.tidy_advice","text":"This can only be a list of type YMLFixit","title":"tidy_advice"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.GlobalParser.tidy_notes","text":"This can only be a list of type TidyNotification","title":"tidy_notes"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals","text":"Global variables for re-use (non-constant). Source code in cpp_linter/__init__.py class Globals : \"\"\"Global variables for re-use (non-constant).\"\"\" PAYLOAD_TIDY = \"\" \"\"\"The accumulated output of clang-tidy (gets appended to OUTPUT)\"\"\" OUTPUT = \"\" \"\"\"The accumulated body of the resulting comment that gets posted.\"\"\" FILES = [] \"\"\"The reponding payload containing info about changed files.\"\"\" EVENT_PAYLOAD = {} \"\"\"The parsed JSON of the event payload.\"\"\" response_buffer = None \"\"\"A shared response object for `requests` module.\"\"\"","title":"Globals"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals.EVENT_PAYLOAD","text":"The parsed JSON of the event payload.","title":"EVENT_PAYLOAD"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals.FILES","text":"The reponding payload containing info about changed files.","title":"FILES"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals.OUTPUT","text":"The accumulated body of the resulting comment that gets posted.","title":"OUTPUT"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals.PAYLOAD_TIDY","text":"The accumulated output of clang-tidy (gets appended to OUTPUT)","title":"PAYLOAD_TIDY"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.Globals.response_buffer","text":"A shared response object for requests module.","title":"response_buffer"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.get_line_cnt_from_cols","text":"Gets a line count and columns offset from a file's absolute offset. Parameters: Name Type Description Default file_path str Path to file. required offset int The byte offset to translate required Returns: Type Description A `tuple` of 2 `int` numbers Index 0 is the line number for the given offset. Index 1 is the column number for the given offset on the line. Source code in cpp_linter/__init__.py def get_line_cnt_from_cols ( file_path : str , offset : int ) -> tuple : \"\"\"Gets a line count and columns offset from a file's absolute offset. Args: file_path: Path to file. offset: The byte offset to translate Returns: A `tuple` of 2 `int` numbers: - Index 0 is the line number for the given offset. - Index 1 is the column number for the given offset on the line. \"\"\" line_cnt = 1 last_lf_pos = 0 cols = 1 file_path = file_path . replace ( \"/\" , os . sep ) # logger.debug(\"Getting line count from %s at offset %d\", file_path, offset) with io . open ( file_path , \"rb\" ) as src_file : max_len = src_file . seek ( 0 , io . SEEK_END ) src_file . seek ( 0 , io . SEEK_SET ) while src_file . tell () != offset and src_file . tell () < max_len : char = src_file . read ( 1 ) if char == b \" \\n \" : line_cnt += 1 last_lf_pos = src_file . tell () - 1 # -1 because LF is part of offset cols = src_file . tell () - last_lf_pos return ( line_cnt , cols )","title":"get_line_cnt_from_cols()"},{"location":"API%20Reference/cpp_linter/#cpp_linter.__init__.log_response_msg","text":"Output the response buffer's message on a failed request. Source code in cpp_linter/__init__.py def log_response_msg (): \"\"\"Output the response buffer's message on a failed request.\"\"\" if Globals . response_buffer . status_code >= 400 : logger . error ( \"response returned message: %s \" , Globals . response_buffer . text )","title":"log_response_msg()"},{"location":"API%20Reference/cpp_linter.run/","text":"Run module \u00b6 Run clang-tidy and clang-format on a list of changed files provided by GitHub's REST API. If executed from command-line, then main() is the entrypoint. See Also github rest API reference for pulls github rest API reference for repos github rest API reference for issues capture_clang_tools_output ( version , checks , style , lines_changed_only ) \u00b6 Execute and capture all output from clang-tidy and clang-format. This aggregates results in the OUTPUT . Parameters: Name Type Description Default version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def capture_clang_tools_output ( version : str , checks : str , style : str , lines_changed_only : bool ): \"\"\"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the [`OUTPUT`][cpp_linter.__init__.Globals.OUTPUT]. Args: version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" tidy_notes = [] # temporary cache of parsed notifications for use in log commands for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" or isinstance ( Globals . FILES , list ) else Globals . FILES [ \"files\" ] ): filename = file [ \"filename\" ] if not os . path . exists ( file [ \"filename\" ]): filename = os . path . split ( file [ \"raw_url\" ])[ 1 ] start_log_group ( f \"Performing checkup on { filename } \" ) run_clang_tidy ( filename , file , version , checks , lines_changed_only ) run_clang_format ( filename , file , version , style , lines_changed_only ) end_log_group () if os . path . getsize ( \"clang_tidy_report.txt\" ): parse_tidy_output () # get clang-tidy fixes from stdout if Globals . PAYLOAD_TIDY : Globals . PAYLOAD_TIDY += \"<hr></details>\" Globals . PAYLOAD_TIDY += f \"<details><summary> { filename } </summary><br> \\n \" for fix in GlobalParser . tidy_notes : Globals . PAYLOAD_TIDY += repr ( fix ) for note in GlobalParser . tidy_notes : tidy_notes . append ( note ) GlobalParser . tidy_notes . clear () # empty list to avoid duplicated output if os . path . getsize ( \"clang_format_output.xml\" ): parse_format_replacements_xml ( filename . replace ( \"/\" , os . sep )) if ( GlobalParser . format_advice and GlobalParser . format_advice [ - 1 ] . replaced_lines ): if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n ## :scroll: \" Globals . OUTPUT += \"Run `clang-format` on the following files \\n \" Globals . OUTPUT += f \"- [ ] { file [ 'filename' ] } \\n \" if Globals . PAYLOAD_TIDY : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n \" else : Globals . OUTPUT += \" \\n --- \\n \" Globals . OUTPUT += \"## :speech_balloon: Output from `clang-tidy` \\n \" Globals . OUTPUT += Globals . PAYLOAD_TIDY GlobalParser . tidy_notes = tidy_notes [:] # restore cache of notifications end_log_group () \u00b6 End a callapsable group of log statements. Source code in cpp_linter/run.py def end_log_group () -> None : \"\"\"End a callapsable group of log statements.\"\"\" log_commander . fatal ( \"::endgroup::\" ) filter_out_non_source_files ( ext_list , ignored , not_ignored , lines_changed_only ) \u00b6 Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's FILES attribute. Parameters: Name Type Description Default ext_list list A list of file extensions that are to be examined. required ignored list A list of paths to explicitly ignore. required not_ignored list A list of paths to explicitly not ignore. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in main() ) when no files to be checked. Source code in cpp_linter/run.py def filter_out_non_source_files ( ext_list : list , ignored : list , not_ignored : list , lines_changed_only : bool ) -> bool : \"\"\"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's [`FILES`][cpp_linter.__init__.Globals.FILES] attribute. Args: ext_list: A list of file extensions that are to be examined. ignored: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. lines_changed_only: A flag that forces focus on only changes in the event's diff info. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" files = [] for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" else Globals . FILES [ \"files\" ] ): if ( os . path . splitext ( file [ \"filename\" ])[ 1 ][ 1 :] in ext_list and not file [ \"status\" ] . endswith ( \"removed\" ) and ( not is_file_in_list ( ignored , file [ \"filename\" ], \"ignored\" ) or is_file_in_list ( not_ignored , file [ \"filename\" ], \"not ignored\" ) ) ): if lines_changed_only and \"patch\" in file . keys (): # get diff details for the file's changes line_filter = { \"name\" : file [ \"filename\" ] . replace ( \"/\" , os . sep ), \"lines\" : [], } file [ \"diff_line_map\" ], line_numb_in_diff = ({}, 0 ) # diff_line_map is a dict for which each # - key is the line number in the file # - value is the line's \"position\" in the diff for i , line in enumerate ( file [ \"patch\" ] . splitlines ()): if line . startswith ( \"@@ -\" ): changed_hunk = line [ line . find ( \" +\" ) + 2 : line . find ( \" @@\" )] changed_hunk = changed_hunk . split ( \",\" ) start_line = int ( changed_hunk [ 0 ]) hunk_length = int ( changed_hunk [ 1 ]) line_filter [ \"lines\" ] . append ( [ start_line , hunk_length + start_line ] ) line_numb_in_diff = start_line elif not line . startswith ( \"-\" ): file [ \"diff_line_map\" ][ line_numb_in_diff ] = i line_filter [ \"lines\" ][ - 1 ][ 1 ] = line_numb_in_diff line_numb_in_diff += 1 file [ \"line_filter\" ] = line_filter elif lines_changed_only : continue files . append ( file ) if files : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in files ]), ) if GITHUB_EVENT_NAME == \"pull_request\" : Globals . FILES = files else : Globals . FILES [ \"files\" ] = files if not os . getenv ( \"CI\" ): # if not executed on a github runner with open ( \".changed_files.json\" , \"w\" , encoding = \"utf-8\" ) as temp : # dump altered json of changed files json . dump ( Globals . FILES , temp , indent = 2 ) else : logger . info ( \"No source files need checking!\" ) return False return True get_list_of_changed_files () \u00b6 Fetch the JSON payload of the event's changed files. Sets the FILES attribute. Source code in cpp_linter/run.py def get_list_of_changed_files () -> None : \"\"\"Fetch the JSON payload of the event's changed files. Sets the [`FILES`][cpp_linter.__init__.Globals.FILES] attribute.\"\"\" start_log_group ( \"Get list of specified source files\" ) files_link = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" if GITHUB_EVENT_NAME == \"pull_request\" : files_link += f \"pulls/ { Globals . EVENT_PAYLOAD [ 'number' ] } /files\" elif GITHUB_EVENT_NAME == \"push\" : files_link += f \"commits/ { GITHUB_SHA } \" else : logger . warning ( \"triggered on unsupported event.\" ) sys . exit ( set_exit_code ( 0 )) logger . info ( \"Fetching files list from url: %s \" , files_link ) Globals . FILES = requests . get ( files_link ) . json () is_file_in_list ( paths , file_name , prompt ) \u00b6 Detirmine if a file is specified in a list of paths and/or filenames. Parameters: Name Type Description Default paths list A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. required file_name str The file's path & name being sought in the paths list. required prompt str A debugging prompt to use when the path is found in the list. required Returns: Type Description bool True if file_name is in the paths list. False if file_name is not in the paths list. Source code in cpp_linter/run.py def is_file_in_list ( paths : list , file_name : str , prompt : str ) -> bool : \"\"\"Detirmine if a file is specified in a list of paths and/or filenames. Args: paths: A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. file_name: The file's path & name being sought in the `paths` list. prompt: A debugging prompt to use when the path is found in the list. Returns: - True if `file_name` is in the `paths` list. - False if `file_name` is not in the `paths` list. \"\"\" for path in paths : result = os . path . commonpath ([ path , file_name ]) . replace ( os . sep , \"/\" ) if result == path : logger . debug ( '\". %s%s \" is %s as specified in the domain \". %s%s \"' , os . sep , file_name , prompt , os . sep , path , ) return True return False list_source_files ( ext_list , ignored_paths , not_ignored ) \u00b6 Make a list of source files to be checked. The resulting list is stored in FILES . Parameters: Name Type Description Default ext_list list A list of file extensions that should by attended. required ignored_paths list A list of paths to explicitly ignore. required not_ignored list A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in main() ) when no files to be checked. Source code in cpp_linter/run.py def list_source_files ( ext_list : list , ignored_paths : list , not_ignored : list ) -> bool : \"\"\"Make a list of source files to be checked. The resulting list is stored in [`FILES`][cpp_linter.__init__.Globals.FILES]. Args: ext_list: A list of file extensions that should by attended. ignored_paths: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" start_log_group ( \"Get list of specified source files\" ) if os . path . exists ( \".gitmodules\" ): submodules = configparser . ConfigParser () submodules . read ( \".gitmodules\" ) for module in submodules . sections (): logger . info ( \"Apending submodule to ignored paths: %s \" , submodules [ module ][ \"path\" ] ) ignored_paths . append ( submodules [ module ][ \"path\" ]) root_path = os . getcwd () for dirpath , _ , filenames in os . walk ( root_path ): path = dirpath . replace ( root_path , \"\" ) . lstrip ( os . sep ) path_parts = path . split ( os . sep ) is_hidden = False for part in path_parts : if part . startswith ( \".\" ): # logger.debug(\"Skipping \\\".%s%s\\\"\", os.sep, path) is_hidden = True break if is_hidden : continue # skip sources in hidden directories logger . debug ( 'Crawling \". %s%s \"' , os . sep , path ) for file in filenames : if os . path . splitext ( file )[ 1 ][ 1 :] in ext_list : file_path = os . path . join ( path , file ) logger . debug ( '\". %s%s \" is a source code file' , os . sep , file_path ) if not is_file_in_list ( ignored_paths , file_path , \"ignored\" ) or is_file_in_list ( not_ignored , file_path , \"not ignored\" ): Globals . FILES . append ({ \"filename\" : file_path }) if Globals . FILES : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in Globals . FILES ]), ) else : logger . info ( \"No source files found.\" ) # this might need to be warning return False return True main () \u00b6 The main script. Source code in cpp_linter/run.py def main (): \"\"\"The main script.\"\"\" # The parsed CLI args args = cli_arg_parser . parse_args () # set logging verbosity logger . setLevel ( int ( args . verbosity )) # prepare ignored paths list ignored , not_ignored = parse_ignore_option ( \"\" if not args . ignore else args . ignore ) # prepare extensions list args . extensions = args . extensions . split ( \",\" ) logger . info ( \"processing %s event\" , GITHUB_EVENT_NAME ) # change working directory os . chdir ( args . repo_root ) exit_early = False if args . files_changed_only : # load event's json info about the workflow run with open ( GITHUB_EVEN_PATH , \"r\" , encoding = \"utf-8\" ) as payload : Globals . EVENT_PAYLOAD = json . load ( payload ) if logger . getEffectiveLevel () <= logging . DEBUG : start_log_group ( \"Event json from the runner\" ) logger . debug ( json . dumps ( Globals . EVENT_PAYLOAD )) end_log_group () get_list_of_changed_files () exit_early = not filter_out_non_source_files ( args . extensions , ignored , not_ignored , args . lines_changed_only if args . files_changed_only else False , ) if not exit_early : verify_files_are_present () else : exit_early = not list_source_files ( args . extensions , ignored , not_ignored ) end_log_group () if exit_early : sys . exit ( set_exit_code ( 0 )) capture_clang_tools_output ( args . version , args . tidy_checks , args . style , args . lines_changed_only ) start_log_group ( \"Posting comment(s)\" ) if args . thread_comments : post_results ( False ) # False is hard-coded to disable diff comments. set_exit_code ( int ( make_annotations ( args . style ))) end_log_group () make_annotations ( style ) \u00b6 Use github log commands to make annotations from clang-format and clang-tidy output. Parameters: Name Type Description Default style str The chosen code style guidelines. The value 'file' is replaced with 'custom style'. required Source code in cpp_linter/run.py def make_annotations ( style : str ) -> bool : \"\"\"Use github log commands to make annotations from clang-format and clang-tidy output. Args: style: The chosen code style guidelines. The value 'file' is replaced with 'custom style'. \"\"\" # log_commander obj's verbosity is hard-coded to show debug statements ret_val = False count = 0 for note in GlobalParser . format_advice : if note . replaced_lines : ret_val = True log_commander . info ( note . log_command ( style )) count += 1 for note in GlobalParser . tidy_notes : ret_val = True log_commander . info ( note . log_command ()) count += 1 logger . info ( \"Created %d annotations\" , count ) return ret_val parse_ignore_option ( paths ) \u00b6 Parse a givven string of paths (separated by a '|') into ignored and not_ignored lists of strings. Parameters: Name Type Description Default paths str This argument conforms to the CLI arg --ignore (or -i ). required Returns: Type Description A tuple of lists in which each list is a set of strings. - index 0 is the ignored list - index 1 is the not_ignored list Source code in cpp_linter/run.py def parse_ignore_option ( paths : str ): \"\"\"Parse a givven string of paths (separated by a '|') into `ignored` and `not_ignored` lists of strings. Args: paths: This argument conforms to the CLI arg `--ignore` (or `-i`). Returns: A tuple of lists in which each list is a set of strings. - index 0 is the `ignored` list - index 1 is the `not_ignored` list \"\"\" ignored , not_ignored = ([], []) paths = paths . split ( \"|\" ) for path in paths : is_included = path . startswith ( \"!\" ) if path . startswith ( \"!./\" if is_included else \"./\" ): path = path . replace ( \"./\" , \"\" , 1 ) # relative dir is assumed path = path . strip () # strip leading/trailing spaces if is_included : not_ignored . append ( path [ 1 :]) else : ignored . append ( path ) if ignored : logger . info ( \"Ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in ignored ), ) if not_ignored : logger . info ( \"Not ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in not_ignored ), ) return ( ignored , not_ignored ) post_diff_comments ( base_url , user_id ) \u00b6 Post comments inside a unified diff (only PRs are supported). Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_diff_comments ( base_url : str , user_id : int ) -> bool : \"\"\"Post comments inside a unified diff (only PRs are supported). Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + \"pulls/comments/\" # for use with comment_id payload = list_diff_comments () logger . info ( \"Posting %d comments\" , len ( payload )) # uncomment the next 3 lines for debug output without posting a comment # for i, comment in enumerate(payload): # logger.debug(\"comments %d: %s\", i, json.dumps(comment, indent=2)) # return # get existing review comments reviews_url = base_url + f 'pulls/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /' Globals . response_buffer = requests . get ( reviews_url + \"comments\" ) existing_comments = json . loads ( Globals . response_buffer . text ) # filter out comments not made by our bot for index , comment in enumerate ( existing_comments ): if not comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): del existing_comments [ index ] # conditionally post comments in the diff for i , body in enumerate ( payload ): # check if comment is already there already_posted = False comment_id = None for comment in existing_comments : if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id and comment [ \"line\" ] == body [ \"line\" ] and comment [ \"path\" ] == payload [ i ][ \"path\" ] ): already_posted = True if comment [ \"body\" ] != body [ \"body\" ]: comment_id = str ( comment [ \"id\" ]) # use this to update comment else : break if already_posted and comment_id is None : logger . info ( \"comment %d already posted\" , i ) continue # don't bother reposting the same comment # update ot create a review comment (in the diff) logger . debug ( \"Payload %d body = %s \" , i , json . dumps ( body )) if comment_id is not None : Globals . response_buffer = requests . patch ( comments_url + comment_id , headers = API_HEADERS , data = json . dumps ({ \"body\" : body [ \"body\" ]}), ) logger . info ( \"Got %d from PATCHing comment %d ( %d )\" , Globals . response_buffer . status_code , i , comment_id , ) log_response_msg () else : Globals . response_buffer = requests . post ( reviews_url + \"comments\" , headers = API_HEADERS , data = json . dumps ( body ) ) logger . info ( \"Got %d from POSTing review comment %d \" , Globals . response_buffer . status_code , i , ) log_response_msg () return bool ( payload ) post_pr_comment ( base_url , user_id ) \u00b6 POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_pr_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f 'issues/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /comments' remove_bot_comments ( comments_url , user_id ) payload = \"\" if Globals . OUTPUT : payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT }, indent = 2 ) ) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( payload ) post_push_comment ( base_url , user_id ) \u00b6 POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_push_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f \"commits/ { GITHUB_SHA } /comments\" remove_bot_comments ( comments_url , user_id ) if Globals . OUTPUT : # diff comments are not supported for push events (yet) payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT })) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d response from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( Globals . OUTPUT ) post_results ( use_diff_comments , user_id = 41898282 ) \u00b6 Post action's results using REST API. Parameters: Name Type Description Default use_diff_comments bool This flag enables making/updating comments in the PR's diff info. required user_id int The user's account ID number. Defaults to the generic bot's ID. 41898282 Source code in cpp_linter/run.py def post_results ( use_diff_comments : bool , user_id : int = 41898282 ): \"\"\"Post action's results using REST API. Args: use_diff_comments: This flag enables making/updating comments in the PR's diff info. user_id: The user's account ID number. Defaults to the generic bot's ID. \"\"\" if not GITHUB_TOKEN : logger . error ( \"The GITHUB_TOKEN is required!\" ) sys . exit ( set_exit_code ( 1 )) base_url = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" checks_passed = True if GITHUB_EVENT_NAME == \"pull_request\" : checks_passed = post_pr_comment ( base_url , user_id ) if use_diff_comments : checks_passed = post_diff_comments ( base_url , user_id ) elif GITHUB_EVENT_NAME == \"push\" : checks_passed = post_push_comment ( base_url , user_id ) set_exit_code ( 1 if checks_passed else 0 ) run_clang_format ( filename , file_obj , version , style , lines_changed_only ) \u00b6 Run clang-format on a certain file Parameters: Name Type Description Default filename str The name of the local file to run clang-format on. required file_obj dict JSON info about the file. required version str The version of clang-format to run. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_format ( filename : str , file_obj : dict , version : str , style : str , lines_changed_only : bool ) -> None : \"\"\"Run clang-format on a certain file Args: filename: The name of the local file to run clang-format on. file_obj: JSON info about the file. version: The version of clang-format to run. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" cmds = [ \"clang-format\" + ( \"\" if sys . platform . startswith ( \"win32\" ) else f \"- { version } \" ), f \"-style= { style } \" , \"--output-replacements-xml\" , ] if lines_changed_only : for line_range in file_obj [ \"line_filter\" ][ \"lines\" ]: cmds . append ( f \"--lines= { line_range [ 0 ] } : { line_range [ 1 ] } \" ) cmds . append ( filename . replace ( \"/\" , os . sep )) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) with open ( \"clang_format_output.xml\" , \"wb\" ) as f_out : f_out . write ( results . stdout ) if results . returncode : logger . warning ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () ) run_clang_tidy ( filename , file_obj , version , checks , lines_changed_only ) \u00b6 Run clang-tidy on a certain file. Parameters: Name Type Description Default filename str The name of the local file to run clang-tidy on. required file_obj dict JSON info about the file. required version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_tidy ( filename : str , file_obj : dict , version : str , checks : str , lines_changed_only : bool ) -> None : \"\"\"Run clang-tidy on a certain file. Args: filename: The name of the local file to run clang-tidy on. file_obj: JSON info about the file. version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if checks == \"-*\" : # if all checks are disabled, then clang-tidy is skipped # clear the clang-tidy output file and exit function with open ( \"clang_tidy_report.txt\" , \"wb\" ) as f_out : return cmds = [ f \"clang-tidy- { version } \" ] if sys . platform . startswith ( \"win32\" ): cmds = [ \"clang-tidy\" ] if checks : cmds . append ( f \"-checks= { checks } \" ) cmds . append ( \"--export-fixes=clang_tidy_output.yml\" ) # cmds.append(f\"--format-style={style}\") if lines_changed_only : logger . info ( \"line_filter = %s \" , json . dumps ( file_obj [ \"line_filter\" ][ \"lines\" ])) cmds . append ( f \"--line-filter= { json . dumps ([ file_obj [ 'line_filter' ]]) } \" ) cmds . append ( filename . replace ( \"/\" , os . sep )) with open ( \"clang_tidy_output.yml\" , \"wb\" ): pass # clear yml file's content before running clang-tidy logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) with open ( \"clang_tidy_report.txt\" , \"wb\" ) as f_out : f_out . write ( results . stdout ) logger . debug ( \"Output from clang-tidy: \\n %s \" , results . stdout . decode ()) if os . path . getsize ( \"clang_tidy_output.yml\" ): parse_tidy_suggestions_yml () # get clang-tidy fixes from yml if results . returncode : logger . warning ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () ) set_exit_code ( override = None ) \u00b6 Set the action's exit code. Parameters: Name Type Description Default override int The number to use when overriding the action's logic. None Returns: Type Description int The exit code that was used. If the override parameter was not passed, then this value will describe (like a bool value) if any checks failed. Source code in cpp_linter/run.py def set_exit_code ( override : int = None ) -> int : \"\"\"Set the action's exit code. Args: override: The number to use when overriding the action's logic. Returns: The exit code that was used. If the `override` parameter was not passed, then this value will describe (like a bool value) if any checks failed. \"\"\" exit_code = override if override is not None else bool ( Globals . OUTPUT ) print ( f \"::set-output name=checks-failed:: { exit_code } \" ) return exit_code start_log_group ( name ) \u00b6 Begin a callapsable group of log statements. Argrs name: The name of the callapsable group Source code in cpp_linter/run.py def start_log_group ( name : str ) -> None : \"\"\"Begin a callapsable group of log statements. Argrs: name: The name of the callapsable group \"\"\" log_commander . fatal ( \"::group:: %s \" , name ) verify_files_are_present () \u00b6 Download the files if not present. Hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. Source code in cpp_linter/run.py def verify_files_are_present () -> None : \"\"\"Download the files if not present. !!! hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. \"\"\" for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" else Globals . FILES [ \"files\" ] ): file_name = file [ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( file_name ): logger . warning ( \"Could not find %s ! Did you checkout the repo?\" , file_name ) logger . info ( \"Downloading file from url: %s \" , file [ \"raw_url\" ]) Globals . response_buffer = requests . get ( file [ \"raw_url\" ]) with open ( os . path . split ( file_name )[ 1 ], \"w\" , encoding = \"utf-8\" ) as temp : temp . write ( Globals . response_buffer . text )","title":"Run module"},{"location":"API%20Reference/cpp_linter.run/#run-module","text":"Run clang-tidy and clang-format on a list of changed files provided by GitHub's REST API. If executed from command-line, then main() is the entrypoint. See Also github rest API reference for pulls github rest API reference for repos github rest API reference for issues","title":"Run module"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.capture_clang_tools_output","text":"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the OUTPUT . Parameters: Name Type Description Default version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def capture_clang_tools_output ( version : str , checks : str , style : str , lines_changed_only : bool ): \"\"\"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the [`OUTPUT`][cpp_linter.__init__.Globals.OUTPUT]. Args: version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" tidy_notes = [] # temporary cache of parsed notifications for use in log commands for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" or isinstance ( Globals . FILES , list ) else Globals . FILES [ \"files\" ] ): filename = file [ \"filename\" ] if not os . path . exists ( file [ \"filename\" ]): filename = os . path . split ( file [ \"raw_url\" ])[ 1 ] start_log_group ( f \"Performing checkup on { filename } \" ) run_clang_tidy ( filename , file , version , checks , lines_changed_only ) run_clang_format ( filename , file , version , style , lines_changed_only ) end_log_group () if os . path . getsize ( \"clang_tidy_report.txt\" ): parse_tidy_output () # get clang-tidy fixes from stdout if Globals . PAYLOAD_TIDY : Globals . PAYLOAD_TIDY += \"<hr></details>\" Globals . PAYLOAD_TIDY += f \"<details><summary> { filename } </summary><br> \\n \" for fix in GlobalParser . tidy_notes : Globals . PAYLOAD_TIDY += repr ( fix ) for note in GlobalParser . tidy_notes : tidy_notes . append ( note ) GlobalParser . tidy_notes . clear () # empty list to avoid duplicated output if os . path . getsize ( \"clang_format_output.xml\" ): parse_format_replacements_xml ( filename . replace ( \"/\" , os . sep )) if ( GlobalParser . format_advice and GlobalParser . format_advice [ - 1 ] . replaced_lines ): if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n ## :scroll: \" Globals . OUTPUT += \"Run `clang-format` on the following files \\n \" Globals . OUTPUT += f \"- [ ] { file [ 'filename' ] } \\n \" if Globals . PAYLOAD_TIDY : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n \" else : Globals . OUTPUT += \" \\n --- \\n \" Globals . OUTPUT += \"## :speech_balloon: Output from `clang-tidy` \\n \" Globals . OUTPUT += Globals . PAYLOAD_TIDY GlobalParser . tidy_notes = tidy_notes [:] # restore cache of notifications","title":"capture_clang_tools_output()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.end_log_group","text":"End a callapsable group of log statements. Source code in cpp_linter/run.py def end_log_group () -> None : \"\"\"End a callapsable group of log statements.\"\"\" log_commander . fatal ( \"::endgroup::\" )","title":"end_log_group()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.filter_out_non_source_files","text":"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's FILES attribute. Parameters: Name Type Description Default ext_list list A list of file extensions that are to be examined. required ignored list A list of paths to explicitly ignore. required not_ignored list A list of paths to explicitly not ignore. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in main() ) when no files to be checked. Source code in cpp_linter/run.py def filter_out_non_source_files ( ext_list : list , ignored : list , not_ignored : list , lines_changed_only : bool ) -> bool : \"\"\"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's [`FILES`][cpp_linter.__init__.Globals.FILES] attribute. Args: ext_list: A list of file extensions that are to be examined. ignored: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. lines_changed_only: A flag that forces focus on only changes in the event's diff info. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" files = [] for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" else Globals . FILES [ \"files\" ] ): if ( os . path . splitext ( file [ \"filename\" ])[ 1 ][ 1 :] in ext_list and not file [ \"status\" ] . endswith ( \"removed\" ) and ( not is_file_in_list ( ignored , file [ \"filename\" ], \"ignored\" ) or is_file_in_list ( not_ignored , file [ \"filename\" ], \"not ignored\" ) ) ): if lines_changed_only and \"patch\" in file . keys (): # get diff details for the file's changes line_filter = { \"name\" : file [ \"filename\" ] . replace ( \"/\" , os . sep ), \"lines\" : [], } file [ \"diff_line_map\" ], line_numb_in_diff = ({}, 0 ) # diff_line_map is a dict for which each # - key is the line number in the file # - value is the line's \"position\" in the diff for i , line in enumerate ( file [ \"patch\" ] . splitlines ()): if line . startswith ( \"@@ -\" ): changed_hunk = line [ line . find ( \" +\" ) + 2 : line . find ( \" @@\" )] changed_hunk = changed_hunk . split ( \",\" ) start_line = int ( changed_hunk [ 0 ]) hunk_length = int ( changed_hunk [ 1 ]) line_filter [ \"lines\" ] . append ( [ start_line , hunk_length + start_line ] ) line_numb_in_diff = start_line elif not line . startswith ( \"-\" ): file [ \"diff_line_map\" ][ line_numb_in_diff ] = i line_filter [ \"lines\" ][ - 1 ][ 1 ] = line_numb_in_diff line_numb_in_diff += 1 file [ \"line_filter\" ] = line_filter elif lines_changed_only : continue files . append ( file ) if files : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in files ]), ) if GITHUB_EVENT_NAME == \"pull_request\" : Globals . FILES = files else : Globals . FILES [ \"files\" ] = files if not os . getenv ( \"CI\" ): # if not executed on a github runner with open ( \".changed_files.json\" , \"w\" , encoding = \"utf-8\" ) as temp : # dump altered json of changed files json . dump ( Globals . FILES , temp , indent = 2 ) else : logger . info ( \"No source files need checking!\" ) return False return True","title":"filter_out_non_source_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.get_list_of_changed_files","text":"Fetch the JSON payload of the event's changed files. Sets the FILES attribute. Source code in cpp_linter/run.py def get_list_of_changed_files () -> None : \"\"\"Fetch the JSON payload of the event's changed files. Sets the [`FILES`][cpp_linter.__init__.Globals.FILES] attribute.\"\"\" start_log_group ( \"Get list of specified source files\" ) files_link = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" if GITHUB_EVENT_NAME == \"pull_request\" : files_link += f \"pulls/ { Globals . EVENT_PAYLOAD [ 'number' ] } /files\" elif GITHUB_EVENT_NAME == \"push\" : files_link += f \"commits/ { GITHUB_SHA } \" else : logger . warning ( \"triggered on unsupported event.\" ) sys . exit ( set_exit_code ( 0 )) logger . info ( \"Fetching files list from url: %s \" , files_link ) Globals . FILES = requests . get ( files_link ) . json ()","title":"get_list_of_changed_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.is_file_in_list","text":"Detirmine if a file is specified in a list of paths and/or filenames. Parameters: Name Type Description Default paths list A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. required file_name str The file's path & name being sought in the paths list. required prompt str A debugging prompt to use when the path is found in the list. required Returns: Type Description bool True if file_name is in the paths list. False if file_name is not in the paths list. Source code in cpp_linter/run.py def is_file_in_list ( paths : list , file_name : str , prompt : str ) -> bool : \"\"\"Detirmine if a file is specified in a list of paths and/or filenames. Args: paths: A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. file_name: The file's path & name being sought in the `paths` list. prompt: A debugging prompt to use when the path is found in the list. Returns: - True if `file_name` is in the `paths` list. - False if `file_name` is not in the `paths` list. \"\"\" for path in paths : result = os . path . commonpath ([ path , file_name ]) . replace ( os . sep , \"/\" ) if result == path : logger . debug ( '\". %s%s \" is %s as specified in the domain \". %s%s \"' , os . sep , file_name , prompt , os . sep , path , ) return True return False","title":"is_file_in_list()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.list_source_files","text":"Make a list of source files to be checked. The resulting list is stored in FILES . Parameters: Name Type Description Default ext_list list A list of file extensions that should by attended. required ignored_paths list A list of paths to explicitly ignore. required not_ignored list A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in main() ) when no files to be checked. Source code in cpp_linter/run.py def list_source_files ( ext_list : list , ignored_paths : list , not_ignored : list ) -> bool : \"\"\"Make a list of source files to be checked. The resulting list is stored in [`FILES`][cpp_linter.__init__.Globals.FILES]. Args: ext_list: A list of file extensions that should by attended. ignored_paths: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" start_log_group ( \"Get list of specified source files\" ) if os . path . exists ( \".gitmodules\" ): submodules = configparser . ConfigParser () submodules . read ( \".gitmodules\" ) for module in submodules . sections (): logger . info ( \"Apending submodule to ignored paths: %s \" , submodules [ module ][ \"path\" ] ) ignored_paths . append ( submodules [ module ][ \"path\" ]) root_path = os . getcwd () for dirpath , _ , filenames in os . walk ( root_path ): path = dirpath . replace ( root_path , \"\" ) . lstrip ( os . sep ) path_parts = path . split ( os . sep ) is_hidden = False for part in path_parts : if part . startswith ( \".\" ): # logger.debug(\"Skipping \\\".%s%s\\\"\", os.sep, path) is_hidden = True break if is_hidden : continue # skip sources in hidden directories logger . debug ( 'Crawling \". %s%s \"' , os . sep , path ) for file in filenames : if os . path . splitext ( file )[ 1 ][ 1 :] in ext_list : file_path = os . path . join ( path , file ) logger . debug ( '\". %s%s \" is a source code file' , os . sep , file_path ) if not is_file_in_list ( ignored_paths , file_path , \"ignored\" ) or is_file_in_list ( not_ignored , file_path , \"not ignored\" ): Globals . FILES . append ({ \"filename\" : file_path }) if Globals . FILES : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in Globals . FILES ]), ) else : logger . info ( \"No source files found.\" ) # this might need to be warning return False return True","title":"list_source_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.main","text":"The main script. Source code in cpp_linter/run.py def main (): \"\"\"The main script.\"\"\" # The parsed CLI args args = cli_arg_parser . parse_args () # set logging verbosity logger . setLevel ( int ( args . verbosity )) # prepare ignored paths list ignored , not_ignored = parse_ignore_option ( \"\" if not args . ignore else args . ignore ) # prepare extensions list args . extensions = args . extensions . split ( \",\" ) logger . info ( \"processing %s event\" , GITHUB_EVENT_NAME ) # change working directory os . chdir ( args . repo_root ) exit_early = False if args . files_changed_only : # load event's json info about the workflow run with open ( GITHUB_EVEN_PATH , \"r\" , encoding = \"utf-8\" ) as payload : Globals . EVENT_PAYLOAD = json . load ( payload ) if logger . getEffectiveLevel () <= logging . DEBUG : start_log_group ( \"Event json from the runner\" ) logger . debug ( json . dumps ( Globals . EVENT_PAYLOAD )) end_log_group () get_list_of_changed_files () exit_early = not filter_out_non_source_files ( args . extensions , ignored , not_ignored , args . lines_changed_only if args . files_changed_only else False , ) if not exit_early : verify_files_are_present () else : exit_early = not list_source_files ( args . extensions , ignored , not_ignored ) end_log_group () if exit_early : sys . exit ( set_exit_code ( 0 )) capture_clang_tools_output ( args . version , args . tidy_checks , args . style , args . lines_changed_only ) start_log_group ( \"Posting comment(s)\" ) if args . thread_comments : post_results ( False ) # False is hard-coded to disable diff comments. set_exit_code ( int ( make_annotations ( args . style ))) end_log_group ()","title":"main()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.make_annotations","text":"Use github log commands to make annotations from clang-format and clang-tidy output. Parameters: Name Type Description Default style str The chosen code style guidelines. The value 'file' is replaced with 'custom style'. required Source code in cpp_linter/run.py def make_annotations ( style : str ) -> bool : \"\"\"Use github log commands to make annotations from clang-format and clang-tidy output. Args: style: The chosen code style guidelines. The value 'file' is replaced with 'custom style'. \"\"\" # log_commander obj's verbosity is hard-coded to show debug statements ret_val = False count = 0 for note in GlobalParser . format_advice : if note . replaced_lines : ret_val = True log_commander . info ( note . log_command ( style )) count += 1 for note in GlobalParser . tidy_notes : ret_val = True log_commander . info ( note . log_command ()) count += 1 logger . info ( \"Created %d annotations\" , count ) return ret_val","title":"make_annotations()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.parse_ignore_option","text":"Parse a givven string of paths (separated by a '|') into ignored and not_ignored lists of strings. Parameters: Name Type Description Default paths str This argument conforms to the CLI arg --ignore (or -i ). required Returns: Type Description A tuple of lists in which each list is a set of strings. - index 0 is the ignored list - index 1 is the not_ignored list Source code in cpp_linter/run.py def parse_ignore_option ( paths : str ): \"\"\"Parse a givven string of paths (separated by a '|') into `ignored` and `not_ignored` lists of strings. Args: paths: This argument conforms to the CLI arg `--ignore` (or `-i`). Returns: A tuple of lists in which each list is a set of strings. - index 0 is the `ignored` list - index 1 is the `not_ignored` list \"\"\" ignored , not_ignored = ([], []) paths = paths . split ( \"|\" ) for path in paths : is_included = path . startswith ( \"!\" ) if path . startswith ( \"!./\" if is_included else \"./\" ): path = path . replace ( \"./\" , \"\" , 1 ) # relative dir is assumed path = path . strip () # strip leading/trailing spaces if is_included : not_ignored . append ( path [ 1 :]) else : ignored . append ( path ) if ignored : logger . info ( \"Ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in ignored ), ) if not_ignored : logger . info ( \"Not ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in not_ignored ), ) return ( ignored , not_ignored )","title":"parse_ignore_option()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_diff_comments","text":"Post comments inside a unified diff (only PRs are supported). Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_diff_comments ( base_url : str , user_id : int ) -> bool : \"\"\"Post comments inside a unified diff (only PRs are supported). Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + \"pulls/comments/\" # for use with comment_id payload = list_diff_comments () logger . info ( \"Posting %d comments\" , len ( payload )) # uncomment the next 3 lines for debug output without posting a comment # for i, comment in enumerate(payload): # logger.debug(\"comments %d: %s\", i, json.dumps(comment, indent=2)) # return # get existing review comments reviews_url = base_url + f 'pulls/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /' Globals . response_buffer = requests . get ( reviews_url + \"comments\" ) existing_comments = json . loads ( Globals . response_buffer . text ) # filter out comments not made by our bot for index , comment in enumerate ( existing_comments ): if not comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): del existing_comments [ index ] # conditionally post comments in the diff for i , body in enumerate ( payload ): # check if comment is already there already_posted = False comment_id = None for comment in existing_comments : if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id and comment [ \"line\" ] == body [ \"line\" ] and comment [ \"path\" ] == payload [ i ][ \"path\" ] ): already_posted = True if comment [ \"body\" ] != body [ \"body\" ]: comment_id = str ( comment [ \"id\" ]) # use this to update comment else : break if already_posted and comment_id is None : logger . info ( \"comment %d already posted\" , i ) continue # don't bother reposting the same comment # update ot create a review comment (in the diff) logger . debug ( \"Payload %d body = %s \" , i , json . dumps ( body )) if comment_id is not None : Globals . response_buffer = requests . patch ( comments_url + comment_id , headers = API_HEADERS , data = json . dumps ({ \"body\" : body [ \"body\" ]}), ) logger . info ( \"Got %d from PATCHing comment %d ( %d )\" , Globals . response_buffer . status_code , i , comment_id , ) log_response_msg () else : Globals . response_buffer = requests . post ( reviews_url + \"comments\" , headers = API_HEADERS , data = json . dumps ( body ) ) logger . info ( \"Got %d from POSTing review comment %d \" , Globals . response_buffer . status_code , i , ) log_response_msg () return bool ( payload )","title":"post_diff_comments()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_pr_comment","text":"POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_pr_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f 'issues/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /comments' remove_bot_comments ( comments_url , user_id ) payload = \"\" if Globals . OUTPUT : payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT }, indent = 2 ) ) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( payload )","title":"post_pr_comment()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_push_comment","text":"POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). Source code in cpp_linter/run.py def post_push_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f \"commits/ { GITHUB_SHA } /comments\" remove_bot_comments ( comments_url , user_id ) if Globals . OUTPUT : # diff comments are not supported for push events (yet) payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT })) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d response from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( Globals . OUTPUT )","title":"post_push_comment()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_results","text":"Post action's results using REST API. Parameters: Name Type Description Default use_diff_comments bool This flag enables making/updating comments in the PR's diff info. required user_id int The user's account ID number. Defaults to the generic bot's ID. 41898282 Source code in cpp_linter/run.py def post_results ( use_diff_comments : bool , user_id : int = 41898282 ): \"\"\"Post action's results using REST API. Args: use_diff_comments: This flag enables making/updating comments in the PR's diff info. user_id: The user's account ID number. Defaults to the generic bot's ID. \"\"\" if not GITHUB_TOKEN : logger . error ( \"The GITHUB_TOKEN is required!\" ) sys . exit ( set_exit_code ( 1 )) base_url = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" checks_passed = True if GITHUB_EVENT_NAME == \"pull_request\" : checks_passed = post_pr_comment ( base_url , user_id ) if use_diff_comments : checks_passed = post_diff_comments ( base_url , user_id ) elif GITHUB_EVENT_NAME == \"push\" : checks_passed = post_push_comment ( base_url , user_id ) set_exit_code ( 1 if checks_passed else 0 )","title":"post_results()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.run_clang_format","text":"Run clang-format on a certain file Parameters: Name Type Description Default filename str The name of the local file to run clang-format on. required file_obj dict JSON info about the file. required version str The version of clang-format to run. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_format ( filename : str , file_obj : dict , version : str , style : str , lines_changed_only : bool ) -> None : \"\"\"Run clang-format on a certain file Args: filename: The name of the local file to run clang-format on. file_obj: JSON info about the file. version: The version of clang-format to run. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" cmds = [ \"clang-format\" + ( \"\" if sys . platform . startswith ( \"win32\" ) else f \"- { version } \" ), f \"-style= { style } \" , \"--output-replacements-xml\" , ] if lines_changed_only : for line_range in file_obj [ \"line_filter\" ][ \"lines\" ]: cmds . append ( f \"--lines= { line_range [ 0 ] } : { line_range [ 1 ] } \" ) cmds . append ( filename . replace ( \"/\" , os . sep )) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) with open ( \"clang_format_output.xml\" , \"wb\" ) as f_out : f_out . write ( results . stdout ) if results . returncode : logger . warning ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () )","title":"run_clang_format()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.run_clang_tidy","text":"Run clang-tidy on a certain file. Parameters: Name Type Description Default filename str The name of the local file to run clang-tidy on. required file_obj dict JSON info about the file. required version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required lines_changed_only bool A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_tidy ( filename : str , file_obj : dict , version : str , checks : str , lines_changed_only : bool ) -> None : \"\"\"Run clang-tidy on a certain file. Args: filename: The name of the local file to run clang-tidy on. file_obj: JSON info about the file. version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if checks == \"-*\" : # if all checks are disabled, then clang-tidy is skipped # clear the clang-tidy output file and exit function with open ( \"clang_tidy_report.txt\" , \"wb\" ) as f_out : return cmds = [ f \"clang-tidy- { version } \" ] if sys . platform . startswith ( \"win32\" ): cmds = [ \"clang-tidy\" ] if checks : cmds . append ( f \"-checks= { checks } \" ) cmds . append ( \"--export-fixes=clang_tidy_output.yml\" ) # cmds.append(f\"--format-style={style}\") if lines_changed_only : logger . info ( \"line_filter = %s \" , json . dumps ( file_obj [ \"line_filter\" ][ \"lines\" ])) cmds . append ( f \"--line-filter= { json . dumps ([ file_obj [ 'line_filter' ]]) } \" ) cmds . append ( filename . replace ( \"/\" , os . sep )) with open ( \"clang_tidy_output.yml\" , \"wb\" ): pass # clear yml file's content before running clang-tidy logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) with open ( \"clang_tidy_report.txt\" , \"wb\" ) as f_out : f_out . write ( results . stdout ) logger . debug ( \"Output from clang-tidy: \\n %s \" , results . stdout . decode ()) if os . path . getsize ( \"clang_tidy_output.yml\" ): parse_tidy_suggestions_yml () # get clang-tidy fixes from yml if results . returncode : logger . warning ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () )","title":"run_clang_tidy()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.set_exit_code","text":"Set the action's exit code. Parameters: Name Type Description Default override int The number to use when overriding the action's logic. None Returns: Type Description int The exit code that was used. If the override parameter was not passed, then this value will describe (like a bool value) if any checks failed. Source code in cpp_linter/run.py def set_exit_code ( override : int = None ) -> int : \"\"\"Set the action's exit code. Args: override: The number to use when overriding the action's logic. Returns: The exit code that was used. If the `override` parameter was not passed, then this value will describe (like a bool value) if any checks failed. \"\"\" exit_code = override if override is not None else bool ( Globals . OUTPUT ) print ( f \"::set-output name=checks-failed:: { exit_code } \" ) return exit_code","title":"set_exit_code()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.start_log_group","text":"Begin a callapsable group of log statements. Argrs name: The name of the callapsable group Source code in cpp_linter/run.py def start_log_group ( name : str ) -> None : \"\"\"Begin a callapsable group of log statements. Argrs: name: The name of the callapsable group \"\"\" log_commander . fatal ( \"::group:: %s \" , name )","title":"start_log_group()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.verify_files_are_present","text":"Download the files if not present. Hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. Source code in cpp_linter/run.py def verify_files_are_present () -> None : \"\"\"Download the files if not present. !!! hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. \"\"\" for file in ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" else Globals . FILES [ \"files\" ] ): file_name = file [ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( file_name ): logger . warning ( \"Could not find %s ! Did you checkout the repo?\" , file_name ) logger . info ( \"Downloading file from url: %s \" , file [ \"raw_url\" ]) Globals . response_buffer = requests . get ( file [ \"raw_url\" ]) with open ( os . path . split ( file_name )[ 1 ], \"w\" , encoding = \"utf-8\" ) as temp : temp . write ( Globals . response_buffer . text )","title":"verify_files_are_present()"},{"location":"API%20Reference/cpp_linter.thread_comments/","text":"thread_comments module \u00b6 A module to house the various functions for traversing/adjusting comments aggregate_format_advice () \u00b6 Aggregate a list of json contents representing advice from clang-format suggestions. Source code in cpp_linter/thread_comments.py def aggregate_format_advice () -> list : \"\"\"Aggregate a list of json contents representing advice from clang-format suggestions.\"\"\" results = [] for index , fmt_advice in enumerate ( GlobalParser . format_advice ): # get original code filename = Globals . FILES [ index ][ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( filename ): # the file had to be downloaded (no git checkout). # thus use only the filename (without the path to the file) filename = os . path . split ( filename )[ 1 ] lines = [] # the list of lines from the src file with open ( filename , encoding = \"utf-8\" ) as temp : lines = temp . readlines () # aggregate clang-format suggestion line = \"\" # the line that concerns the fix for fixed_line in fmt_advice . replaced_lines : # clang-format can include advice that starts/ends outside the diff's domain in_range = False ranges = Globals . FILES [ index ][ \"line_filter\" ][ \"lines\" ] for scope in ranges : if fixed_line . line in range ( scope [ 0 ], scope [ 1 ] + 1 ): in_range = True if not in_range : continue # line is out of scope for diff, so skip this fix # assemble the suggestion body = \"## :scroll: clang-format advice \\n ```suggestion \\n \" line = lines [ fixed_line . line - 1 ] # logger.debug(\"%d >>> %s\", fixed_line.line, line[:-1]) for fix_index , line_fix in enumerate ( fixed_line . replacements ): # logger.debug( # \"%s >>> %s\", repr(line_fix), line_fix.text.encode(\"utf-8\") # ) if fix_index : last_fix = fixed_line . replacements [ fix_index - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : line_fix . cols - 1 ] body += line_fix . text else : body += line [: line_fix . cols - 1 ] + line_fix . text # complete suggestion with original src code and closing md fence last_fix = fixed_line . replacements [ - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" # logger.debug(\"body <<< %s\", body) # create a suggestion from clang-format advice results . append ( { \"body\" : body , \"commit_id\" : GITHUB_SHA , \"line\" : fixed_line . line , \"path\" : fmt_advice . filename , \"side\" : \"RIGHT\" , } ) return results aggregate_tidy_advice () \u00b6 Aggregate a list of json contents representing advice from clang-tidy suggestions. Source code in cpp_linter/thread_comments.py def aggregate_tidy_advice () -> list : \"\"\"Aggregate a list of json contents representing advice from clang-tidy suggestions.\"\"\" results = [] for index , fixit in enumerate ( GlobalParser . tidy_advice ): for diag in fixit . diagnostics : # base body of comment body = \"<!-- cpp linter action --> \\n ## :speech_balloon: Clang-tidy \\n **\" body += diag . name + \"** \\n >\" + diag . message # get original code filename = Globals . FILES [ index ][ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( filename ): # the file had to be downloaded (no git checkout). # thus use only the filename (without the path to the file) filename = os . path . split ( filename )[ 1 ] lines = [] # the list of lines in a file with open ( filename , encoding = \"utf-8\" ) as temp : lines = temp . readlines () # aggregate clang-tidy advice suggestion = \" \\n ```suggestion \\n \" is_multiline_fix = False fix_lines = [] # a list of line numbers for the suggested fixes line = \"\" # the line that concerns the fix/comment for i , tidy_fix in enumerate ( diag . replacements ): line = lines [ tidy_fix . line - 1 ] if not fix_lines : fix_lines . append ( tidy_fix . line ) elif tidy_fix . line not in fix_lines : is_multiline_fix = True break if i : # if this isn't the first tidy_fix for the same line last_fix = diag . replacements [ i - 1 ] suggestion += ( line [ last_fix . cols + last_fix . null_len - 1 : tidy_fix . cols - 1 ] + tidy_fix . text . decode () ) else : suggestion += line [: tidy_fix . cols - 1 ] + tidy_fix . text . decode () if not is_multiline_fix and diag . replacements : # complete suggestion with original src code and closing md fence last_fix = diag . replacements [ len ( diag . replacements ) - 1 ] suggestion += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" body += suggestion results . append ( { \"body\" : body , \"commit_id\" : GITHUB_SHA , \"line\" : diag . line , \"path\" : fixit . filename , \"side\" : \"RIGHT\" , } ) return results concatenate_comments ( tidy_advice , format_advice ) \u00b6 Concatenate comments made to the same line of the same file. Source code in cpp_linter/thread_comments.py def concatenate_comments ( tidy_advice : list , format_advice : list ) -> list : \"\"\"Concatenate comments made to the same line of the same file.\"\"\" # traverse comments from clang-format for index , comment_body in enumerate ( format_advice ): # check for comments from clang-tidy on the same line comment_index = None for i , payload in enumerate ( tidy_advice ): if ( payload [ \"line\" ] == comment_body [ \"line\" ] and payload [ \"path\" ] == comment_body [ \"path\" ] ): comment_index = i # mark this comment for concatenation break if comment_index is not None : # append clang-format advice to clang-tidy output/suggestion tidy_advice [ comment_index ][ \"body\" ] += \" \\n \" + comment_body [ \"body\" ] del format_advice [ index ] # remove duplicate comment return tidy_advice + format_advice find_review ( reviews , user_id ) \u00b6 Find a review created by a certain user ID. Parameters: Name Type Description Default reviews dict the JSON object fetched via GIT REST API. required user_id int The user account's ID number required Returns: Type Description Optional[int] An ID that corresponds to the specified user_id . Source code in cpp_linter/thread_comments.py def find_review ( reviews : dict , user_id : int ) -> Union [ int , None ]: \"\"\"Find a review created by a certain user ID. Args: reviews: the JSON object fetched via GIT REST API. user_id: The user account's ID number Returns: An ID that corresponds to the specified `user_id`. \"\"\" review_id = None for review in reviews : if int ( review [ \"user\" ][ \"id\" ]) == user_id and review [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): review_id = int ( review [ \"id\" ]) break # there will only be 1 review from this action, so break when found logger . info ( \" review_id: %d \" , review_id ) return review_id get_review_id ( reviews_url , user_id ) \u00b6 Dismiss all stale reviews (only the ones made by our bot). Parameters: Name Type Description Default reviews_url str The URL used to fetch the review comments. required user_id int The user's account id number. required Returns: Type Description int The ID number of the review created by the action's generic bot. Source code in cpp_linter/thread_comments.py def get_review_id ( reviews_url : str , user_id : int ) -> int : \"\"\"Dismiss all stale reviews (only the ones made by our bot). Args: reviews_url: The URL used to fetch the review comments. user_id: The user's account id number. Returns: The ID number of the review created by the action's generic bot. \"\"\" logger . info ( \" review_url: %s \" , reviews_url ) Globals . response_buffer = requests . get ( reviews_url ) review_id = find_review ( json . loads ( Globals . response_buffer . text ), user_id ) if review_id is None : # create a PR review Globals . response_buffer = requests . post ( reviews_url , headers = API_HEADERS , data = json . dumps ( { \"body\" : \"<!-- cpp linter action --> \\n \" \"CPP Linter Action found no problems\" , \"event\" : \"COMMENTED\" , } ), ) logger . info ( \"Got %d from POSTing new(/temp) PR review\" , Globals . response_buffer . status_code , ) Globals . response_buffer = requests . get ( reviews_url ) if Globals . response_buffer . status_code != 200 : log_response_msg () raise RuntimeError ( \"could not create a review for commemts\" ) reviews = json . loads ( Globals . response_buffer . text ) reviews . reverse () # traverse the list in reverse review_id = find_review ( reviews , user_id ) return review_id list_diff_comments () \u00b6 Aggregate list of comments for use in the event's diff. This function assumes that the CLI option --diff-only is set to True. Returns: Type Description list A list of comments (each element as json content). Source code in cpp_linter/thread_comments.py def list_diff_comments () -> list : \"\"\"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option `--diff-only` is set to True. Returns: A list of comments (each element as json content). \"\"\" tidy_advice = aggregate_tidy_advice () format_advice = aggregate_format_advice () results = concatenate_comments ( tidy_advice , format_advice ) return results remove_bot_comments ( comments_url , user_id ) \u00b6 Traverse the list of comments made by a specific user and remove all. Parameters: Name Type Description Default comments_url str The URL used to fetch the comments. required user_id int The user's account id number. required Source code in cpp_linter/thread_comments.py def remove_bot_comments ( comments_url : str , user_id : int ): \"\"\"Traverse the list of comments made by a specific user and remove all. Args: comments_url: The URL used to fetch the comments. user_id: The user's account id number. \"\"\" logger . info ( \"comments_url: %s \" , comments_url ) Globals . response_buffer = requests . get ( comments_url ) comments = Globals . response_buffer . json () for i , comment in enumerate ( comments ): # only serach for comments from the user's ID and # whose comment body begins with a specific html comment if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id # the specific html comment is our action's name and comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ) ): # remove other outdated comments but don't remove the last comment Globals . response_buffer = requests . delete ( comment [ \"url\" ], headers = API_HEADERS , ) logger . info ( \"Got %d from DELETE %s \" , Globals . response_buffer . status_code , comment [ \"url\" ][ comment [ \"url\" ] . find ( \".com\" ) + 4 :], ) log_response_msg () del comments [ i ] logger . debug ( \"comment id %d from user %s ( %d )\" , comment [ \"id\" ], comment [ \"user\" ][ \"login\" ], comment [ \"user\" ][ \"id\" ], ) with open ( \"comments.json\" , \"w\" , encoding = \"utf-8\" ) as json_comments : json . dump ( comments , json_comments , indent = 4 )","title":"thread_comments module"},{"location":"API%20Reference/cpp_linter.thread_comments/#thread_comments-module","text":"A module to house the various functions for traversing/adjusting comments","title":"thread_comments module"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.aggregate_format_advice","text":"Aggregate a list of json contents representing advice from clang-format suggestions. Source code in cpp_linter/thread_comments.py def aggregate_format_advice () -> list : \"\"\"Aggregate a list of json contents representing advice from clang-format suggestions.\"\"\" results = [] for index , fmt_advice in enumerate ( GlobalParser . format_advice ): # get original code filename = Globals . FILES [ index ][ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( filename ): # the file had to be downloaded (no git checkout). # thus use only the filename (without the path to the file) filename = os . path . split ( filename )[ 1 ] lines = [] # the list of lines from the src file with open ( filename , encoding = \"utf-8\" ) as temp : lines = temp . readlines () # aggregate clang-format suggestion line = \"\" # the line that concerns the fix for fixed_line in fmt_advice . replaced_lines : # clang-format can include advice that starts/ends outside the diff's domain in_range = False ranges = Globals . FILES [ index ][ \"line_filter\" ][ \"lines\" ] for scope in ranges : if fixed_line . line in range ( scope [ 0 ], scope [ 1 ] + 1 ): in_range = True if not in_range : continue # line is out of scope for diff, so skip this fix # assemble the suggestion body = \"## :scroll: clang-format advice \\n ```suggestion \\n \" line = lines [ fixed_line . line - 1 ] # logger.debug(\"%d >>> %s\", fixed_line.line, line[:-1]) for fix_index , line_fix in enumerate ( fixed_line . replacements ): # logger.debug( # \"%s >>> %s\", repr(line_fix), line_fix.text.encode(\"utf-8\") # ) if fix_index : last_fix = fixed_line . replacements [ fix_index - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : line_fix . cols - 1 ] body += line_fix . text else : body += line [: line_fix . cols - 1 ] + line_fix . text # complete suggestion with original src code and closing md fence last_fix = fixed_line . replacements [ - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" # logger.debug(\"body <<< %s\", body) # create a suggestion from clang-format advice results . append ( { \"body\" : body , \"commit_id\" : GITHUB_SHA , \"line\" : fixed_line . line , \"path\" : fmt_advice . filename , \"side\" : \"RIGHT\" , } ) return results","title":"aggregate_format_advice()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.aggregate_tidy_advice","text":"Aggregate a list of json contents representing advice from clang-tidy suggestions. Source code in cpp_linter/thread_comments.py def aggregate_tidy_advice () -> list : \"\"\"Aggregate a list of json contents representing advice from clang-tidy suggestions.\"\"\" results = [] for index , fixit in enumerate ( GlobalParser . tidy_advice ): for diag in fixit . diagnostics : # base body of comment body = \"<!-- cpp linter action --> \\n ## :speech_balloon: Clang-tidy \\n **\" body += diag . name + \"** \\n >\" + diag . message # get original code filename = Globals . FILES [ index ][ \"filename\" ] . replace ( \"/\" , os . sep ) if not os . path . exists ( filename ): # the file had to be downloaded (no git checkout). # thus use only the filename (without the path to the file) filename = os . path . split ( filename )[ 1 ] lines = [] # the list of lines in a file with open ( filename , encoding = \"utf-8\" ) as temp : lines = temp . readlines () # aggregate clang-tidy advice suggestion = \" \\n ```suggestion \\n \" is_multiline_fix = False fix_lines = [] # a list of line numbers for the suggested fixes line = \"\" # the line that concerns the fix/comment for i , tidy_fix in enumerate ( diag . replacements ): line = lines [ tidy_fix . line - 1 ] if not fix_lines : fix_lines . append ( tidy_fix . line ) elif tidy_fix . line not in fix_lines : is_multiline_fix = True break if i : # if this isn't the first tidy_fix for the same line last_fix = diag . replacements [ i - 1 ] suggestion += ( line [ last_fix . cols + last_fix . null_len - 1 : tidy_fix . cols - 1 ] + tidy_fix . text . decode () ) else : suggestion += line [: tidy_fix . cols - 1 ] + tidy_fix . text . decode () if not is_multiline_fix and diag . replacements : # complete suggestion with original src code and closing md fence last_fix = diag . replacements [ len ( diag . replacements ) - 1 ] suggestion += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" body += suggestion results . append ( { \"body\" : body , \"commit_id\" : GITHUB_SHA , \"line\" : diag . line , \"path\" : fixit . filename , \"side\" : \"RIGHT\" , } ) return results","title":"aggregate_tidy_advice()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.concatenate_comments","text":"Concatenate comments made to the same line of the same file. Source code in cpp_linter/thread_comments.py def concatenate_comments ( tidy_advice : list , format_advice : list ) -> list : \"\"\"Concatenate comments made to the same line of the same file.\"\"\" # traverse comments from clang-format for index , comment_body in enumerate ( format_advice ): # check for comments from clang-tidy on the same line comment_index = None for i , payload in enumerate ( tidy_advice ): if ( payload [ \"line\" ] == comment_body [ \"line\" ] and payload [ \"path\" ] == comment_body [ \"path\" ] ): comment_index = i # mark this comment for concatenation break if comment_index is not None : # append clang-format advice to clang-tidy output/suggestion tidy_advice [ comment_index ][ \"body\" ] += \" \\n \" + comment_body [ \"body\" ] del format_advice [ index ] # remove duplicate comment return tidy_advice + format_advice","title":"concatenate_comments()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.find_review","text":"Find a review created by a certain user ID. Parameters: Name Type Description Default reviews dict the JSON object fetched via GIT REST API. required user_id int The user account's ID number required Returns: Type Description Optional[int] An ID that corresponds to the specified user_id . Source code in cpp_linter/thread_comments.py def find_review ( reviews : dict , user_id : int ) -> Union [ int , None ]: \"\"\"Find a review created by a certain user ID. Args: reviews: the JSON object fetched via GIT REST API. user_id: The user account's ID number Returns: An ID that corresponds to the specified `user_id`. \"\"\" review_id = None for review in reviews : if int ( review [ \"user\" ][ \"id\" ]) == user_id and review [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): review_id = int ( review [ \"id\" ]) break # there will only be 1 review from this action, so break when found logger . info ( \" review_id: %d \" , review_id ) return review_id","title":"find_review()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.get_review_id","text":"Dismiss all stale reviews (only the ones made by our bot). Parameters: Name Type Description Default reviews_url str The URL used to fetch the review comments. required user_id int The user's account id number. required Returns: Type Description int The ID number of the review created by the action's generic bot. Source code in cpp_linter/thread_comments.py def get_review_id ( reviews_url : str , user_id : int ) -> int : \"\"\"Dismiss all stale reviews (only the ones made by our bot). Args: reviews_url: The URL used to fetch the review comments. user_id: The user's account id number. Returns: The ID number of the review created by the action's generic bot. \"\"\" logger . info ( \" review_url: %s \" , reviews_url ) Globals . response_buffer = requests . get ( reviews_url ) review_id = find_review ( json . loads ( Globals . response_buffer . text ), user_id ) if review_id is None : # create a PR review Globals . response_buffer = requests . post ( reviews_url , headers = API_HEADERS , data = json . dumps ( { \"body\" : \"<!-- cpp linter action --> \\n \" \"CPP Linter Action found no problems\" , \"event\" : \"COMMENTED\" , } ), ) logger . info ( \"Got %d from POSTing new(/temp) PR review\" , Globals . response_buffer . status_code , ) Globals . response_buffer = requests . get ( reviews_url ) if Globals . response_buffer . status_code != 200 : log_response_msg () raise RuntimeError ( \"could not create a review for commemts\" ) reviews = json . loads ( Globals . response_buffer . text ) reviews . reverse () # traverse the list in reverse review_id = find_review ( reviews , user_id ) return review_id","title":"get_review_id()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.list_diff_comments","text":"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option --diff-only is set to True. Returns: Type Description list A list of comments (each element as json content). Source code in cpp_linter/thread_comments.py def list_diff_comments () -> list : \"\"\"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option `--diff-only` is set to True. Returns: A list of comments (each element as json content). \"\"\" tidy_advice = aggregate_tidy_advice () format_advice = aggregate_format_advice () results = concatenate_comments ( tidy_advice , format_advice ) return results","title":"list_diff_comments()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.remove_bot_comments","text":"Traverse the list of comments made by a specific user and remove all. Parameters: Name Type Description Default comments_url str The URL used to fetch the comments. required user_id int The user's account id number. required Source code in cpp_linter/thread_comments.py def remove_bot_comments ( comments_url : str , user_id : int ): \"\"\"Traverse the list of comments made by a specific user and remove all. Args: comments_url: The URL used to fetch the comments. user_id: The user's account id number. \"\"\" logger . info ( \"comments_url: %s \" , comments_url ) Globals . response_buffer = requests . get ( comments_url ) comments = Globals . response_buffer . json () for i , comment in enumerate ( comments ): # only serach for comments from the user's ID and # whose comment body begins with a specific html comment if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id # the specific html comment is our action's name and comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ) ): # remove other outdated comments but don't remove the last comment Globals . response_buffer = requests . delete ( comment [ \"url\" ], headers = API_HEADERS , ) logger . info ( \"Got %d from DELETE %s \" , Globals . response_buffer . status_code , comment [ \"url\" ][ comment [ \"url\" ] . find ( \".com\" ) + 4 :], ) log_response_msg () del comments [ i ] logger . debug ( \"comment id %d from user %s ( %d )\" , comment [ \"id\" ], comment [ \"user\" ][ \"login\" ], comment [ \"user\" ][ \"id\" ], ) with open ( \"comments.json\" , \"w\" , encoding = \"utf-8\" ) as json_comments : json . dump ( comments , json_comments , indent = 4 )","title":"remove_bot_comments()"}]}